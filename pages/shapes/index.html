<!doctype html>
<html>
<head>
<meta charset='utf-8'>
<title>
Boolean shape operations
</title>
<base href='..'>
</head>
<body>
<div data-reactid=".1v0wg97xh4w" data-react-checksum="-647545668"><div class="ribbon" data-reactid=".1v0wg97xh4w.0"><img src="images/ribbon.png" alt="This page on GitHub" usemap="#githubmap" width="200px" height="149px" data-reactid=".1v0wg97xh4w.0.0"/><map name="githubmap" data-reactid=".1v0wg97xh4w.0.1"><area shape="poly" coords="30,0, 200,0, 200,114" href="http://github.com/pomax/BezierInfo-2" alt="This page on GitHub" data-reactid=".1v0wg97xh4w.0.1.0"/></map></div><header data-reactid=".1v0wg97xh4w.1"><h1 data-reactid=".1v0wg97xh4w.1.0">A Primer on Bézier Curves</h1><h2 data-reactid=".1v0wg97xh4w.1.1">A free, online book for when you really need to know how to do Bézier things.</h2></header><div data-reactid=".1v0wg97xh4w.2"><table class="relatives before" data-reactid=".1v0wg97xh4w.2.0"><tbody data-reactid=".1v0wg97xh4w.2.0.0"><tr data-reactid=".1v0wg97xh4w.2.0.0.0"><td data-reactid=".1v0wg97xh4w.2.0.0.0.0"><a class="prev" href="polybezier" data-reactid=".1v0wg97xh4w.2.0.0.0.0.0">29. Forming poly-Bézier curves</a></td><td class="toc" data-reactid=".1v0wg97xh4w.2.0.0.0.1"><a class="" href="/" data-reactid=".1v0wg97xh4w.2.0.0.0.1.0">ToC</a></td><td data-reactid=".1v0wg97xh4w.2.0.0.0.2"><a class="next" href="projections" data-reactid=".1v0wg97xh4w.2.0.0.0.2.0">31. Projecting a point onto a Bézier curve</a></td></tr></tbody></table><section data-reactid=".1v0wg97xh4w.2.$shapes"><h2 data-num="30" data-reactid=".1v0wg97xh4w.2.$shapes.0"><a href="#shapes" data-reactid=".1v0wg97xh4w.2.$shapes.0.0">Boolean shape operations</a></h2><p data-reactid=".1v0wg97xh4w.2.$shapes.1">We can apply the topics covered so far in this primer to effect boolean shape operations: getting the union, intersection, or exclusion, between two or more shapes that involve Bézier curves. For simplicity (well.. sort of, more homogeneity), we&#x27;ll be looking at Poly-Bézier shapes only, but a shape that consists of a mix of lines and Bézier curves is technically a simplification (although it does mean we need to write a definition for the class of shapes that mix lines and Bézier curves. Since poly-Bézier curves are a superset, we&#x27;ll be using those in the following examples)</p><p data-reactid=".1v0wg97xh4w.2.$shapes.2">The procedure for performing boolean operations consists, broadly, of four steps:</p><ol data-reactid=".1v0wg97xh4w.2.$shapes.3"><li data-reactid=".1v0wg97xh4w.2.$shapes.3.0">Find the intersection points between both shapes,</li><li data-reactid=".1v0wg97xh4w.2.$shapes.3.1">cut up the shapes into multiple sections between these intersections,</li><li data-reactid=".1v0wg97xh4w.2.$shapes.3.2">discard any section that isn&#x27;t part of the desired operation&#x27;s resultant shape, and</li><li data-reactid=".1v0wg97xh4w.2.$shapes.3.3">link up the remaining sections to form the new shape.</li></ol><p data-reactid=".1v0wg97xh4w.2.$shapes.4">Finding all intersections between two poly-Bézier curves, or any poly-line-section shape, is similar to the iterative algorithm discussed in the section on curve/curve intersection. For each segment in the poly-Bézier curve we check whether its bounding box overlaps with any of the segment bounding boxes in the other poly-Bézier curve. If so, we run normal intersection detection.</p><p data-reactid=".1v0wg97xh4w.2.$shapes.5">After we found all intersection points, we split up our poly-Bézier curves, making sure to record which of the newly formed poly-Bézier curves might potentially link up at the points we split the originals up at. This will let us quickly glue poly-Bézier curves back together after the next step.</p><p data-reactid=".1v0wg97xh4w.2.$shapes.6">Once we have all the new poly-Bézier curves, we run the first step of the desired boolean operation.</p><ul data-reactid=".1v0wg97xh4w.2.$shapes.7"><li data-reactid=".1v0wg97xh4w.2.$shapes.7.0">Union: discard all poly-Bézier curves that lie &quot;inside&quot; our union of our shapes. E.g. if we want the union of two overlapping circles, the resulting shape is the outline.</li><li data-reactid=".1v0wg97xh4w.2.$shapes.7.1">Intersection: discard all poly-Bézier curves that lie &quot;outside&quot; the intersection of the two shapes. E.g. if we want the intersection of two overlapping circles, the resulting shape is the tapered ellipse where they overlap.</li><li data-reactid=".1v0wg97xh4w.2.$shapes.7.2">Exclusion: none of the sections are discarded, but we will need to link the shapes back up in a special way. Flip any section that would qualify for removal under UNION rules.</li></ul><table class="sketch" data-reactid=".1v0wg97xh4w.2.$shapes.8"><tbody data-reactid=".1v0wg97xh4w.2.$shapes.8.0"><tr data-reactid=".1v0wg97xh4w.2.$shapes.8.0.0"><td class="labeled-image" data-reactid=".1v0wg97xh4w.2.$shapes.8.0.0.0"><img src="images/op_base.gif" height="169px" data-reactid=".1v0wg97xh4w.2.$shapes.8.0.0.0.0"/><p data-reactid=".1v0wg97xh4w.2.$shapes.8.0.0.0.1">Two overlapping shapes.</p></td><td class="labeled-image" data-reactid=".1v0wg97xh4w.2.$shapes.8.0.0.1"><img src="images/op_union.gif" height="169px" data-reactid=".1v0wg97xh4w.2.$shapes.8.0.0.1.0"/><p data-reactid=".1v0wg97xh4w.2.$shapes.8.0.0.1.1">The unified region.</p></td><td class="labeled-image" data-reactid=".1v0wg97xh4w.2.$shapes.8.0.0.2"><img src="images/op_intersection.gif" height="169px" data-reactid=".1v0wg97xh4w.2.$shapes.8.0.0.2.0"/><p data-reactid=".1v0wg97xh4w.2.$shapes.8.0.0.2.1">Their intersection.</p></td><td class="labeled-image" data-reactid=".1v0wg97xh4w.2.$shapes.8.0.0.3"><img src="images/op_exclusion.gif" height="169px" data-reactid=".1v0wg97xh4w.2.$shapes.8.0.0.3.0"/><p data-reactid=".1v0wg97xh4w.2.$shapes.8.0.0.3.1">Their exclusion regions.</p></td></tr></tbody></table><p data-reactid=".1v0wg97xh4w.2.$shapes.9"><span data-reactid=".1v0wg97xh4w.2.$shapes.9.0">The main complication in the outlined procedure here is determining how sections qualify in terms of being &quot;inside&quot; and &quot;outside&quot; of our shapes. For this, we need to be able to perform point-in-shape detection, for which we&#x27;ll use a classic algorithm: getting the &quot;crossing number&quot; by using ray casting, and then testing for &quot;insidedness&quot; by applying the </span><a href="http://folk.uio.no/bjornw/doc/bifrost-ref/bifrost-ref-12.html" data-reactid=".1v0wg97xh4w.2.$shapes.9.1">even-odd rule</a><span data-reactid=".1v0wg97xh4w.2.$shapes.9.2">: For any point and any shape, we can cast a ray from our point, to some point that we know lies outside of the shape (such as a corner of our drawing surface). We then count how many times that line crosses our shape (remember that we can perform line/curve intersection detection quite easily). If the number of times it crosses the shape&#x27;s outline is even, the point did not actually lie inside our shape. If the number of intersections is odd, our point did lie inside out shape. With that knowledge, we can decide whether to treat a section that such a point lies on &quot;needs removal&quot; (under union rules), &quot;needs preserving&quot; (under intersection rules), or &quot;needs flipping&quot; (under exclusion rules).</span></p><p data-reactid=".1v0wg97xh4w.2.$shapes.a"><span data-reactid=".1v0wg97xh4w.2.$shapes.a.0">These operations are expensive, and implementing your own code for this is generally a bad idea if there is already a geometry package available for your language of choice. In this case, for JavaScript the most excellent </span><a href="http://paperjs.org" data-reactid=".1v0wg97xh4w.2.$shapes.a.1">Paper.js</a><span data-reactid=".1v0wg97xh4w.2.$shapes.a.2"> already comes with all the code in place to perform efficient boolean shape operations, so rather that implement an inferior version here, I can strongly recommend the Paper.js library if you intend to do any boolean shape work.</span></p><p data-reactid=".1v0wg97xh4w.2.$shapes.b">The following graphic shows Paper.js doing its thing for two shapes: one static, and one that is linked to your mouse pointer. If you move the mouse around, you&#x27;ll see how the shape intersections are resolved. The base shapes are outlined in blue, and the boolean result is coloured red.</p><figure class="false" data-reactid=".1v0wg97xh4w.2.$shapes.c"><canvas tabindex="0" data-reactid=".1v0wg97xh4w.2.$shapes.c.0"></canvas><figcaption data-reactid=".1v0wg97xh4w.2.$shapes.c.1"><span data-reactid=".1v0wg97xh4w.2.$shapes.c.1.0">Boolean shape operations with Paper.js</span><span data-reactid=".1v0wg97xh4w.2.$shapes.c.1.1"> </span><br data-reactid=".1v0wg97xh4w.2.$shapes.c.1.2:0"/><button class="selected" data-reactid=".1v0wg97xh4w.2.$shapes.c.1.2:1:$unite">unite</button><button data-reactid=".1v0wg97xh4w.2.$shapes.c.1.2:1:$intersect">intersect</button><button data-reactid=".1v0wg97xh4w.2.$shapes.c.1.2:1:$exclude">exclude</button><button data-reactid=".1v0wg97xh4w.2.$shapes.c.1.2:1:$subtract">subtract</button></figcaption></figure></section><table class="relatives after" data-reactid=".1v0wg97xh4w.2.2"><tbody data-reactid=".1v0wg97xh4w.2.2.0"><tr data-reactid=".1v0wg97xh4w.2.2.0.0"><td data-reactid=".1v0wg97xh4w.2.2.0.0.0"><a class="prev" href="polybezier" data-reactid=".1v0wg97xh4w.2.2.0.0.0.0">29. Forming poly-Bézier curves</a></td><td class="toc" data-reactid=".1v0wg97xh4w.2.2.0.0.1"><a class="" href="/" data-reactid=".1v0wg97xh4w.2.2.0.0.1.0">ToC</a></td><td data-reactid=".1v0wg97xh4w.2.2.0.0.2"><a class="next" href="projections" data-reactid=".1v0wg97xh4w.2.2.0.0.2.0">31. Projecting a point onto a Bézier curve</a></td></tr></tbody></table></div><footer class="copyright" data-reactid=".1v0wg97xh4w.3"><span data-reactid=".1v0wg97xh4w.3.0">This article is © 2011-2016 to me, Mike &quot;Pomax&quot; Kamermans, but the text, code, and images are </span><a href="https://github.com/Pomax/bezierinfo/blob/gh-pages/LICENSE.md" data-reactid=".1v0wg97xh4w.3.1">almost no rights reserved</a><span data-reactid=".1v0wg97xh4w.3.2">. Go do something cool with it!</span></footer></div>
</body>
</html>