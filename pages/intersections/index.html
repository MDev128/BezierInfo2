<!doctype html>
<html>
<head>
<meta charset='utf-8'>
<title>
Intersections
</title>
<base href='..'>
</head>
<body>
<div data-reactid=".eau6c4p69s" data-react-checksum="-1794391292"><div class="ribbon" data-reactid=".eau6c4p69s.0"><img src="images/ribbon.png" alt="This page on GitHub" usemap="#githubmap" width="200px" height="149px" data-reactid=".eau6c4p69s.0.0"/><map name="githubmap" data-reactid=".eau6c4p69s.0.1"><area shape="poly" coords="30,0, 200,0, 200,114" href="http://github.com/pomax/BezierInfo-2" alt="This page on GitHub" data-reactid=".eau6c4p69s.0.1.0"/></map></div><header data-reactid=".eau6c4p69s.1"><h1 data-reactid=".eau6c4p69s.1.0">A Primer on Bézier Curves</h1><h2 data-reactid=".eau6c4p69s.1.1">A free, online book for when you really need to know how to do Bézier things.</h2></header><div data-reactid=".eau6c4p69s.2"><table class="relatives before" data-reactid=".eau6c4p69s.2.0"><tbody data-reactid=".eau6c4p69s.2.0.0"><tr data-reactid=".eau6c4p69s.2.0.0.0"><td data-reactid=".eau6c4p69s.2.0.0.0.0"><a class="prev" href="tracing" data-reactid=".eau6c4p69s.2.0.0.0.0.0">21. Tracing a curve at fixed distance intervals</a></td><td class="toc" data-reactid=".eau6c4p69s.2.0.0.0.1"><a class="" href="/" data-reactid=".eau6c4p69s.2.0.0.0.1.0">ToC</a></td><td data-reactid=".eau6c4p69s.2.0.0.0.2"><a class="next" href="curveintersection" data-reactid=".eau6c4p69s.2.0.0.0.2.0">23. Curve/curve intersection</a></td></tr></tbody></table><section data-reactid=".eau6c4p69s.2.$intersections"><h2 data-num="22" data-reactid=".eau6c4p69s.2.$intersections.0"><a href="#intersections" data-reactid=".eau6c4p69s.2.$intersections.0.0">Intersections</a></h2><p data-reactid=".eau6c4p69s.2.$intersections.1"><span data-reactid=".eau6c4p69s.2.$intersections.1.0">Let&#x27;s look at some more things we will want to do with Bézier curves. Almost immediately after figuring out how to get bounding boxes to work, people tend to run into the problem that even though the minimal bounding box (based on rotation) is tight, it&#x27;s not sufficient to perform true collision detection. It&#x27;s a good first step to make sure there </span><em data-reactid=".eau6c4p69s.2.$intersections.1.1">might</em><span data-reactid=".eau6c4p69s.2.$intersections.1.2"> be a collision (if there is no bounding box overlap, there can&#x27;t be one), but in order to do real collision detection we need to know whether or not there&#x27;s an intersection on the actual curve.</span></p><p data-reactid=".eau6c4p69s.2.$intersections.2">We&#x27;ll do this in steps, because it&#x27;s a bit of a journey to get to curve/curve intersection checking. First, let&#x27;s start simple, by implementing a line-line intersection checker. While we can solve this the traditional calculus way (determine the functions for both lines, then compute the intersection by equating them and solving for two unknowns), linear algebra actually offers a nicer solution.</p><h3 data-reactid=".eau6c4p69s.2.$intersections.3">Line-line intersections</h3><p id="intersection_ll" data-reactid=".eau6c4p69s.2.$intersections.4"><span data-reactid=".eau6c4p69s.2.$intersections.4.0">if we have two line segments with two coordinates each, segments A-B and C-D, we can find the intersection of the lines these segments are an intervals on by linear algebra, using the procedure outlined in this </span><a href="http://www.topcoder.com/tc?module=Static&amp;d1=tutorials&amp;d2=geometry2#line_line_intersection" data-reactid=".eau6c4p69s.2.$intersections.4.1">top coder</a><span data-reactid=".eau6c4p69s.2.$intersections.4.2"> article. Of course, we need to make sure that the intersection isn&#x27;t just on the lines our line segments lie on, but also on our line segments themselves, so after we find the intersection we need to verify it lies without the bounds of our original line segments.</span></p><p data-reactid=".eau6c4p69s.2.$intersections.5"></p><p data-reactid=".eau6c4p69s.2.$intersections.6">The following graphic implements this intersection detection, showing a red point for an intersection on the lines our segments lie on (thus being a virtual intersection point), and a green point for an intersection that lies on both segments (being a real intersection point).</p><figure class="false" data-reactid=".eau6c4p69s.2.$intersections.7"><canvas tabindex="0" data-reactid=".eau6c4p69s.2.$intersections.7.0"></canvas><figcaption data-reactid=".eau6c4p69s.2.$intersections.7.1"><span data-reactid=".eau6c4p69s.2.$intersections.7.1.0">Line/line intersections</span><span data-reactid=".eau6c4p69s.2.$intersections.7.1.1"> </span></figcaption></figure><div class="howtocode" data-reactid=".eau6c4p69s.2.$intersections.8"><h3 data-reactid=".eau6c4p69s.2.$intersections.8.0">Implementing line-line intersections</h3><p data-reactid=".eau6c4p69s.2.$intersections.8.1">Let&#x27;s have a look at how to implement a line-line intersection checking function. The basics are covered in the article mentioned above, but sometimes you need more function signatures, because you might not want to call your function with eight distinct parameters. Maybe you&#x27;re using point structs or the line. Let&#x27;s get coding:</p><pre data-reactid=".eau6c4p69s.2.$intersections.8.2"><span data-reactid=".eau6c4p69s.2.$intersections.8.2.0">lli8 = function(x1,y1,x2,y2,x3,y3,x4,y4):</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.1">
</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.2">  var nx=(x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.3">
</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.4">      ny=(x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4),</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.5">
</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.6">      d=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.7">
</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.8">  if d=0:</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.9">
</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.a">    return false</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.b">
</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.c">  return point(nx/d, ny/d)</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.d">
</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.e">
</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.f">lli4 = function(p1, p2, p3, p4):</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.g">
</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.h">  var x1 = p1.x, y1 = p1.y,</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.i">
</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.j">      x2 = p2.x, y2 = p2.y,</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.k">
</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.l">      x3 = p3.x, y3 = p3.y,</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.m">
</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.n">      x4 = p4.x, y4 = p4.y;</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.o">
</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.p">  return lli8(x1,y1,x2,y2,x3,y3,x4,y4)</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.q">
</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.r">
</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.s">lli = function(line1, line2):</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.t">
</span><span data-reactid=".eau6c4p69s.2.$intersections.8.2.u">  return lli4(line1.p1, line1.p2, line2.p1, line2.p2)</span></pre></div><h3 data-reactid=".eau6c4p69s.2.$intersections.9">What about curve-line intersections?</h3><p data-reactid=".eau6c4p69s.2.$intersections.a">Curve/line intersection is more work, but we&#x27;ve already seen the techniques we need to use in order to perform it: first we translate/rotate both the line and curve together, in such a way that the line coincides with the x-axis. This will position the curve in a way that makes it cross the line at points where its y-function is zero. By doing this, the problem of finding intersections between a curve and a line has now become the problem of performing root finding on our translated/rotated curve, as we already covered in the section on finding extremities.</p><figure class="false" data-reactid=".eau6c4p69s.2.$intersections.b"><canvas tabindex="0" data-reactid=".eau6c4p69s.2.$intersections.b.0"></canvas><figcaption data-reactid=".eau6c4p69s.2.$intersections.b.1"><span data-reactid=".eau6c4p69s.2.$intersections.b.1.0">Quadratic curve/line intersections</span><span data-reactid=".eau6c4p69s.2.$intersections.b.1.1"> </span></figcaption></figure><figure class="false" data-reactid=".eau6c4p69s.2.$intersections.c"><canvas tabindex="0" data-reactid=".eau6c4p69s.2.$intersections.c.0"></canvas><figcaption data-reactid=".eau6c4p69s.2.$intersections.c.1"><span data-reactid=".eau6c4p69s.2.$intersections.c.1.0">Cubic curve/line intersections</span><span data-reactid=".eau6c4p69s.2.$intersections.c.1.1"> </span></figcaption></figure><p data-reactid=".eau6c4p69s.2.$intersections.d">Curve/curve intersection, however, is more complicated. Since we have no straight line to align to, we can&#x27;t simply align one of the curves and be left with a simple procedure. Instead, we&#x27;ll need to apply two techniques we&#x27;ve not covered yet: de Casteljau&#x27;s algorithm, and curve splitting.</p></section><table class="relatives after" data-reactid=".eau6c4p69s.2.2"><tbody data-reactid=".eau6c4p69s.2.2.0"><tr data-reactid=".eau6c4p69s.2.2.0.0"><td data-reactid=".eau6c4p69s.2.2.0.0.0"><a class="prev" href="tracing" data-reactid=".eau6c4p69s.2.2.0.0.0.0">21. Tracing a curve at fixed distance intervals</a></td><td class="toc" data-reactid=".eau6c4p69s.2.2.0.0.1"><a class="" href="/" data-reactid=".eau6c4p69s.2.2.0.0.1.0">ToC</a></td><td data-reactid=".eau6c4p69s.2.2.0.0.2"><a class="next" href="curveintersection" data-reactid=".eau6c4p69s.2.2.0.0.2.0">23. Curve/curve intersection</a></td></tr></tbody></table></div><footer class="copyright" data-reactid=".eau6c4p69s.3"><span data-reactid=".eau6c4p69s.3.0">This article is © 2011-2016 to me, Mike &quot;Pomax&quot; Kamermans, but the text, code, and images are </span><a href="https://github.com/Pomax/bezierinfo/blob/gh-pages/LICENSE.md" data-reactid=".eau6c4p69s.3.1">almost no rights reserved</a><span data-reactid=".eau6c4p69s.3.2">. Go do something cool with it!</span></footer></div>
</body>
</html>