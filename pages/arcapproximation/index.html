<!doctype html>
<html>
<head>
<meta charset='utf-8'>
<title>
Approximating Bézier curves with circular arcs
</title>
<base href='..'>
</head>
<body>
<div data-reactid=".y4ly32u4g" data-react-checksum="-1471877219"><div class="ribbon" data-reactid=".y4ly32u4g.0"><img src="images/ribbon.png" alt="This page on GitHub" usemap="#githubmap" width="200px" height="149px" data-reactid=".y4ly32u4g.0.0"/><map name="githubmap" data-reactid=".y4ly32u4g.0.1"><area shape="poly" coords="30,0, 200,0, 200,114" href="http://github.com/pomax/BezierInfo-2" alt="This page on GitHub" data-reactid=".y4ly32u4g.0.1.0"/></map></div><header data-reactid=".y4ly32u4g.1"><h1 data-reactid=".y4ly32u4g.1.0">A Primer on Bézier Curves</h1><h2 data-reactid=".y4ly32u4g.1.1">A free, online book for when you really need to know how to do Bézier things.</h2></header><div data-reactid=".y4ly32u4g.2"><table class="relatives before" data-reactid=".y4ly32u4g.2.0"><tbody data-reactid=".y4ly32u4g.2.0.0"><tr data-reactid=".y4ly32u4g.2.0.0.0"><td data-reactid=".y4ly32u4g.2.0.0.0.0"><a class="prev" href="circles_cubic" data-reactid=".y4ly32u4g.2.0.0.0.0.0">35. Circles and cubic Bézier curves</a></td><td class="toc" data-reactid=".y4ly32u4g.2.0.0.0.1"><a class="" href="/" data-reactid=".y4ly32u4g.2.0.0.0.1.0">ToC</a></td><td data-reactid=".y4ly32u4g.2.0.0.0.2"></td></tr></tbody></table><section data-reactid=".y4ly32u4g.2.$arcapproximation"><h2 data-num="36" data-reactid=".y4ly32u4g.2.$arcapproximation.0"><a href="#arcapproximation" data-reactid=".y4ly32u4g.2.$arcapproximation.0.0">Approximating Bézier curves with circular arcs</a></h2><p data-reactid=".y4ly32u4g.2.$arcapproximation.1">Let&#x27;s look at doing the exact opposite of the previous section: rather than approximating circular arc using Bézier curves, let&#x27;s approximate Bézier curves using circular arcs.</p><p data-reactid=".y4ly32u4g.2.$arcapproximation.2">We already saw in the section on circle approximation that this will never yield a perfect equivalent, but sometimes you need circular arcs, such as when you&#x27;re working with fabrication machinery, or simple vector languages that understand lines and circles, but not much else.</p><p data-reactid=".y4ly32u4g.2.$arcapproximation.3">The approach is fairly simple: pick a starting point on the curve, and pick two points that are further along the curve. Determine the circle that goes through those three points, and see if it fits the part of the curve we&#x27;re trying to approximate. Decent fit? Try spacing the points further apart. Bad fit? Try spacing the points closer together. Keep doing this until you&#x27;ve found the &quot;good approximation/bad approximation&quot; boundary, record the &quot;good&quot; arc, and then move the starting point up to overlap the end point we previously found. Rinse and repeat until we&#x27;ve covered the entire curve.</p><p data-reactid=".y4ly32u4g.2.$arcapproximation.4"><span data-reactid=".y4ly32u4g.2.$arcapproximation.4.0">So: step 1, how do we find a circle through three points? That part is actually really simple. You may remember (if you ever learned it!) that a line between two points on a circle is called a </span><a href="https://en.wikipedia.org/wiki/Chord_%28geometry%29" data-reactid=".y4ly32u4g.2.$arcapproximation.4.1">chord</a><span data-reactid=".y4ly32u4g.2.$arcapproximation.4.2">, and one property of chords is that the line from the center of any chord, perpendicular to that chord, passes through the center of the circle.</span></p><p data-reactid=".y4ly32u4g.2.$arcapproximation.5">So: if we have have three points, we have three (different) chords, and consequently, three (different) lines that go from those chords through the center of the circle. So we find the centers of the chords, find the perpendicular lines, find the intersection of those lines, and thus find the center of the circle.</p><p data-reactid=".y4ly32u4g.2.$arcapproximation.6">The following graphic shows this procedure with a different colour for each chord and its associated perpendicular through the center. You can move the points around as much as you like, those lines will always meet!</p><figure class="false" data-reactid=".y4ly32u4g.2.$arcapproximation.7"><canvas tabindex="0" data-reactid=".y4ly32u4g.2.$arcapproximation.7.0"></canvas><figcaption data-reactid=".y4ly32u4g.2.$arcapproximation.7.1"><span data-reactid=".y4ly32u4g.2.$arcapproximation.7.1.0">Finding a circle through three points</span><span data-reactid=".y4ly32u4g.2.$arcapproximation.7.1.1"> </span></figcaption></figure><p data-reactid=".y4ly32u4g.2.$arcapproximation.8">So, with the procedure on how to find a circle through three points, finding the arc through those points is straight-forward: pick one of the three points as start point, pick another as an end point, and the arc has to necessarily go from the start point, over the remaining point, to the end point.</p><p data-reactid=".y4ly32u4g.2.$arcapproximation.9">So how can we convert a Bezier curve into a (sequence of) circular arc(s)?</p><ul data-reactid=".y4ly32u4g.2.$arcapproximation.a"><li data-reactid=".y4ly32u4g.2.$arcapproximation.a.0"><span data-reactid=".y4ly32u4g.2.$arcapproximation.a.0.0">Start at </span><em data-reactid=".y4ly32u4g.2.$arcapproximation.a.0.1">t=0</em></li><li data-reactid=".y4ly32u4g.2.$arcapproximation.a.1"><span data-reactid=".y4ly32u4g.2.$arcapproximation.a.1.0">Pick two points further down the curve at some value </span><em data-reactid=".y4ly32u4g.2.$arcapproximation.a.1.1">m = t + n</em><span data-reactid=".y4ly32u4g.2.$arcapproximation.a.1.2"> and </span><em data-reactid=".y4ly32u4g.2.$arcapproximation.a.1.3">e = t + 2n</em></li><li data-reactid=".y4ly32u4g.2.$arcapproximation.a.2">Find the arc that these points define</li><li data-reactid=".y4ly32u4g.2.$arcapproximation.a.3"><span data-reactid=".y4ly32u4g.2.$arcapproximation.a.3.0">Determine how close the found arc is to the curve:</span><ul data-reactid=".y4ly32u4g.2.$arcapproximation.a.3.1"><li data-reactid=".y4ly32u4g.2.$arcapproximation.a.3.1.0"><span data-reactid=".y4ly32u4g.2.$arcapproximation.a.3.1.0.0">Pick two additional points </span><em data-reactid=".y4ly32u4g.2.$arcapproximation.a.3.1.0.1">e1 = t + n/2</em><span data-reactid=".y4ly32u4g.2.$arcapproximation.a.3.1.0.2"> and </span><em data-reactid=".y4ly32u4g.2.$arcapproximation.a.3.1.0.3">e2 = t + n + n/2</em><span data-reactid=".y4ly32u4g.2.$arcapproximation.a.3.1.0.4">.</span></li><li data-reactid=".y4ly32u4g.2.$arcapproximation.a.3.1.1"><span data-reactid=".y4ly32u4g.2.$arcapproximation.a.3.1.1.0">These points, if the arc is a good approximation of the curve interval chosen, should lie </span><em data-reactid=".y4ly32u4g.2.$arcapproximation.a.3.1.1.1">on</em><span data-reactid=".y4ly32u4g.2.$arcapproximation.a.3.1.1.2"> the circle, so their distance to the center of the circle should be the same as the distance from any of the three other points to the center.</span></li><li data-reactid=".y4ly32u4g.2.$arcapproximation.a.3.1.2"><span data-reactid=".y4ly32u4g.2.$arcapproximation.a.3.1.2.0">For point points, determine the (absolute) error between the radius of the circle, and the</span><em data-reactid=".y4ly32u4g.2.$arcapproximation.a.3.1.2.1">actual</em><span data-reactid=".y4ly32u4g.2.$arcapproximation.a.3.1.2.2"> distance from the center of the circle to the point on the curve.</span></li><li data-reactid=".y4ly32u4g.2.$arcapproximation.a.3.1.3">If this error is too high, we consider the arc bad, and try a smaller interval.</li></ul></li></ul><p data-reactid=".y4ly32u4g.2.$arcapproximation.b"><span data-reactid=".y4ly32u4g.2.$arcapproximation.b.0">The result of this is shown in the next graphic: we start at a guaranteed failure: s=0, e=1. That&#x27;s the entire curve. The midpoint is simply at </span><em data-reactid=".y4ly32u4g.2.$arcapproximation.b.1">t=0.5</em><span data-reactid=".y4ly32u4g.2.$arcapproximation.b.2">, and then we start performing a </span><a href="https://en.wikipedia.org/wiki/Binary_search_algorithm" data-reactid=".y4ly32u4g.2.$arcapproximation.b.3">Binary Search</a><span data-reactid=".y4ly32u4g.2.$arcapproximation.b.4">.</span></p><ol data-reactid=".y4ly32u4g.2.$arcapproximation.c"><li data-reactid=".y4ly32u4g.2.$arcapproximation.c.0"><span data-reactid=".y4ly32u4g.2.$arcapproximation.c.0.0">We start with </span><span data-reactid=".y4ly32u4g.2.$arcapproximation.c.0.1">1</span></li><li data-reactid=".y4ly32u4g.2.$arcapproximation.c.1"><span data-reactid=".y4ly32u4g.2.$arcapproximation.c.1.0">That&#x27;ll fail, so we retry with the interval halved: </span><span data-reactid=".y4ly32u4g.2.$arcapproximation.c.1.1">0.5</span></li><ul data-reactid=".y4ly32u4g.2.$arcapproximation.c.2"><li data-reactid=".y4ly32u4g.2.$arcapproximation.c.2.0"><span data-reactid=".y4ly32u4g.2.$arcapproximation.c.2.0.0">If that arc&#x27;s good, we move back up by half distance: </span><span data-reactid=".y4ly32u4g.2.$arcapproximation.c.2.0.1">0.75</span><span data-reactid=".y4ly32u4g.2.$arcapproximation.c.2.0.2">.</span></li><li data-reactid=".y4ly32u4g.2.$arcapproximation.c.2.1"><span data-reactid=".y4ly32u4g.2.$arcapproximation.c.2.1.0">However, if the arc was still bad, we move </span><em data-reactid=".y4ly32u4g.2.$arcapproximation.c.2.1.1">down</em><span data-reactid=".y4ly32u4g.2.$arcapproximation.c.2.1.2"> by half the distance: </span><span data-reactid=".y4ly32u4g.2.$arcapproximation.c.2.1.3">0.25</span><span data-reactid=".y4ly32u4g.2.$arcapproximation.c.2.1.4">.</span></li></ul><li data-reactid=".y4ly32u4g.2.$arcapproximation.c.3">We keep doing this over and over until we have two arcs found in sequence of which the first arc is good, and the second arc is bad. When we find that pair, we&#x27;ve found the boundary between a good approximation and a bad approximation, and we pick the former</li></ol><p data-reactid=".y4ly32u4g.2.$arcapproximation.d"><span data-reactid=".y4ly32u4g.2.$arcapproximation.d.0">The following graphic shows the result of this approach, with a default error threshold of 0.5, meaning that if an arc is off by a </span><em data-reactid=".y4ly32u4g.2.$arcapproximation.d.1">combined</em><span data-reactid=".y4ly32u4g.2.$arcapproximation.d.2"> half pixel over both verification points, then we treat the arc as bad. This is an extremely simple error policy, but already works really well. Note that the graphic is still interactive, and you can use your up and down arrow keys keys to increase or decrease the error threshold, to see what the effect of a smaller or larger error threshold is.</span></p><figure class="false" data-reactid=".y4ly32u4g.2.$arcapproximation.e"><canvas tabindex="0" data-reactid=".y4ly32u4g.2.$arcapproximation.e.0"></canvas><figcaption data-reactid=".y4ly32u4g.2.$arcapproximation.e.1"><span data-reactid=".y4ly32u4g.2.$arcapproximation.e.1.0">Arc approximation of a Bézier curve</span><span data-reactid=".y4ly32u4g.2.$arcapproximation.e.1.1"> </span></figcaption></figure><p data-reactid=".y4ly32u4g.2.$arcapproximation.f"><span data-reactid=".y4ly32u4g.2.$arcapproximation.f.0">With that in place, all that&#x27;s left now is to &quot;restart&quot; the procedure by treating the found arc&#x27;s end point as the new to-be-determined arc&#x27;s starting point, and using points further down the curve. We keep trying this until the found end point is for </span><em data-reactid=".y4ly32u4g.2.$arcapproximation.f.1">t=1</em><span data-reactid=".y4ly32u4g.2.$arcapproximation.f.2">, at which point we are done. Again, the following graphic allows for up and down arrow key input to increase or decrease the error threshold, so you can see how picking a different threshold changes the number of arcs that are necessary to reasonably approximate a curve:</span></p><figure class="false" data-reactid=".y4ly32u4g.2.$arcapproximation.g"><canvas tabindex="0" data-reactid=".y4ly32u4g.2.$arcapproximation.g.0"></canvas><figcaption data-reactid=".y4ly32u4g.2.$arcapproximation.g.1"><span data-reactid=".y4ly32u4g.2.$arcapproximation.g.1.0">Arc approximation of a Bézier curve</span><span data-reactid=".y4ly32u4g.2.$arcapproximation.g.1.1"> </span></figcaption></figure><p data-reactid=".y4ly32u4g.2.$arcapproximation.h">So... what is this good for? Obviously, If you&#x27;re working with technologies that can&#x27;t do curves, but can do lines and circles, then the answer is pretty straight-forward, but what else? There are some reasons why you might need this technique: using circular arcs means you can determine whether a coordinate lies &quot;on&quot; your curve really easily: simply compute the distance to each circular arc center, and if any of those are close to the arc radii, at an angle betwee the arc start and end: bingo, this point can be treated as lying &quot;on the curve&quot;. Another benefit is that this approximation is &quot;linear&quot;: you can almost trivially travel along the arcs at fixed speed. You can also trivially compute the arc length of the approximated curve (it&#x27;s a bit like curve flattening). The only thing to bear in mind is that this is a lossy equivalence: things that you compute based on the approximation are guaranteed &quot;off&quot; by some small value, and depending on how much precision you need, arc approximation is either going to be super useful, or completely useless. It&#x27;s up to you to decide which, based on your application!</p></section><table class="relatives after" data-reactid=".y4ly32u4g.2.2"><tbody data-reactid=".y4ly32u4g.2.2.0"><tr data-reactid=".y4ly32u4g.2.2.0.0"><td data-reactid=".y4ly32u4g.2.2.0.0.0"><a class="prev" href="circles_cubic" data-reactid=".y4ly32u4g.2.2.0.0.0.0">35. Circles and cubic Bézier curves</a></td><td class="toc" data-reactid=".y4ly32u4g.2.2.0.0.1"><a class="" href="/" data-reactid=".y4ly32u4g.2.2.0.0.1.0">ToC</a></td><td data-reactid=".y4ly32u4g.2.2.0.0.2"></td></tr></tbody></table></div><footer class="copyright" data-reactid=".y4ly32u4g.3"><span data-reactid=".y4ly32u4g.3.0">This article is © 2011-2016 to me, Mike &quot;Pomax&quot; Kamermans, but the text, code, and images are </span><a href="https://github.com/Pomax/bezierinfo/blob/gh-pages/LICENSE.md" data-reactid=".y4ly32u4g.3.1">almost no rights reserved</a><span data-reactid=".y4ly32u4g.3.2">. Go do something cool with it!</span></footer></div>
</body>
</html>