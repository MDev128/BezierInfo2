<!doctype html>
<html>
<head>
<meta charset='utf-8'>
<title>
The mathematics of Bézier curves
</title>
<base href='..'>
</head>
<body>
<div data-reactid=".2cwjy2rb1mo" data-react-checksum="-1907352182"><div class="ribbon" data-reactid=".2cwjy2rb1mo.0"><img src="images/ribbon.png" alt="This page on GitHub" usemap="#githubmap" width="200px" height="149px" data-reactid=".2cwjy2rb1mo.0.0"/><map name="githubmap" data-reactid=".2cwjy2rb1mo.0.1"><area shape="poly" coords="30,0, 200,0, 200,114" href="http://github.com/pomax/BezierInfo-2" alt="This page on GitHub" data-reactid=".2cwjy2rb1mo.0.1.0"/></map></div><header data-reactid=".2cwjy2rb1mo.1"><h1 data-reactid=".2cwjy2rb1mo.1.0">A Primer on Bézier Curves</h1><h2 data-reactid=".2cwjy2rb1mo.1.1">A free, online book for when you really need to know how to do Bézier things.</h2></header><div data-reactid=".2cwjy2rb1mo.2"><table class="relatives before" data-reactid=".2cwjy2rb1mo.2.0"><tbody data-reactid=".2cwjy2rb1mo.2.0.0"><tr data-reactid=".2cwjy2rb1mo.2.0.0.0"><td data-reactid=".2cwjy2rb1mo.2.0.0.0.0"><a class="prev" href="whatis" data-reactid=".2cwjy2rb1mo.2.0.0.0.0.0">2. So what makes a Bézier Curve?</a></td><td class="toc" data-reactid=".2cwjy2rb1mo.2.0.0.0.1"><a class="" href="/" data-reactid=".2cwjy2rb1mo.2.0.0.0.1.0">ToC</a></td><td data-reactid=".2cwjy2rb1mo.2.0.0.0.2"><a class="next" href="control" data-reactid=".2cwjy2rb1mo.2.0.0.0.2.0">4. Controlling Bézier curvatures</a></td></tr></tbody></table><section data-reactid=".2cwjy2rb1mo.2.$explanation"><h2 data-num="3" data-reactid=".2cwjy2rb1mo.2.$explanation.0"><a href="#explanation" data-reactid=".2cwjy2rb1mo.2.$explanation.0.0">The mathematics of Bézier curves</a></h2><p data-reactid=".2cwjy2rb1mo.2.$explanation.1"><span data-reactid=".2cwjy2rb1mo.2.$explanation.1.0">Bézier curves are a form of &quot;parametric&quot; function. Mathematically speaking, parametric functions are cheats: a &quot;function&quot; is actually a well defined term representing a mapping from any number of inputs to a </span><strong data-reactid=".2cwjy2rb1mo.2.$explanation.1.1">single</strong><span data-reactid=".2cwjy2rb1mo.2.$explanation.1.2"> output. Numbers go in, a single number comes out. Change the numbers that go in, and the number that comes out is still a single number. Parametric functions cheat. They basically say &quot;alright, well, we want multiple values coming out, so we&#x27;ll just use more than one function&quot;. An illustration: Let&#x27;s say we have a function that maps some value, let&#x27;s call it </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.1.3">x</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.1.4">, to some other value, using some kind of number manipulation:</span></p><p data-reactid=".2cwjy2rb1mo.2.$explanation.2"><img class="LaTeX SVG" src="images/latex/785e792c343b71d4e674ac94d8800940b30917ac.svg" style="width:6.22485rem;height:1.125rem;" data-reactid=".2cwjy2rb1mo.2.$explanation.2.0"/></p><p data-reactid=".2cwjy2rb1mo.2.$explanation.3"><span data-reactid=".2cwjy2rb1mo.2.$explanation.3.0">The notation </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.3.1">f(x)</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.3.2"> is the standard way to show that it&#x27;s a function (by convention called </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.3.3">f</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.3.4"> if we&#x27;re only listing one) and its output changes based on one variable (in this case, </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.3.5">x</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.3.6">). Change </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.3.7">x</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.3.8">, and the output for </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.3.9">f(x)</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.3.a"> changes.</span></p><p data-reactid=".2cwjy2rb1mo.2.$explanation.4">So far so good. Now, let&#x27;s look at parametric functions, and how they cheat. Let&#x27;s take the following two functions:</p><p data-reactid=".2cwjy2rb1mo.2.$explanation.5"><img class="LaTeX SVG" src="images/latex/0dfe7562b43441e72201ff4cdd2e8b6e2e3ecb2d.svg" style="width:6.525rem;height:2.6248500000000003rem;" data-reactid=".2cwjy2rb1mo.2.$explanation.5.0"/></p><p data-reactid=".2cwjy2rb1mo.2.$explanation.6"><span data-reactid=".2cwjy2rb1mo.2.$explanation.6.0">There&#x27;s nothing really remarkable about them, they&#x27;re just a sine and cosine function, but you&#x27;ll notice the inputs have different names. If we change the value for </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.6.1">a</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.6.2">, we&#x27;re not going to change the output value for </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.6.3">f(b)</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.6.4">, since </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.6.5">a</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.6.6"> isn&#x27;t used in that function. Parametric functions cheat by changing that. In a parametric function all the different functions share a variable, like this:</span></p><p data-reactid=".2cwjy2rb1mo.2.$explanation.7"><img class="LaTeX SVG" src="images/latex/ed6f533530199d1e99b3319ba137c1327b0459c0.svg" style="width:7.349849999999999rem;height:2.6248500000000003rem;" data-reactid=".2cwjy2rb1mo.2.$explanation.7.0"/></p><p data-reactid=".2cwjy2rb1mo.2.$explanation.8"><span data-reactid=".2cwjy2rb1mo.2.$explanation.8.0">Multiple functions, but only one variable. If we change the value for </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.8.1">t</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.8.2">, we change the outcome of both </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.8.3"><span data-reactid=".2cwjy2rb1mo.2.$explanation.8.3.0">f</span><sub data-reactid=".2cwjy2rb1mo.2.$explanation.8.3.1">a</sub><span data-reactid=".2cwjy2rb1mo.2.$explanation.8.3.2">(t)</span></i><span data-reactid=".2cwjy2rb1mo.2.$explanation.8.4"> and </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.8.5"><span data-reactid=".2cwjy2rb1mo.2.$explanation.8.5.0">f</span><sub data-reactid=".2cwjy2rb1mo.2.$explanation.8.5.1">b</sub><span data-reactid=".2cwjy2rb1mo.2.$explanation.8.5.2">(t)</span></i><span data-reactid=".2cwjy2rb1mo.2.$explanation.8.6">. You might wonder how that&#x27;s useful, and the answer is actually pretty simple: if we change the labels </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.8.7"><span data-reactid=".2cwjy2rb1mo.2.$explanation.8.7.0">f</span><sub data-reactid=".2cwjy2rb1mo.2.$explanation.8.7.1">a</sub><span data-reactid=".2cwjy2rb1mo.2.$explanation.8.7.2">(t)</span></i><span data-reactid=".2cwjy2rb1mo.2.$explanation.8.8"> and </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.8.9"><span data-reactid=".2cwjy2rb1mo.2.$explanation.8.9.0">f</span><sub data-reactid=".2cwjy2rb1mo.2.$explanation.8.9.1">b</sub><span data-reactid=".2cwjy2rb1mo.2.$explanation.8.9.2">(t)</span></i><span data-reactid=".2cwjy2rb1mo.2.$explanation.8.a"> with what we usually mean with them for parametric curves, things might be a lot more obvious:</span></p><p data-reactid=".2cwjy2rb1mo.2.$explanation.9"><img class="LaTeX SVG" src="images/latex/ea632ea75d6a2aeb6fe69c07feb6e76f81884746.svg" style="width:5.77485rem;height:2.6248500000000003rem;" data-reactid=".2cwjy2rb1mo.2.$explanation.9.0"/></p><p data-reactid=".2cwjy2rb1mo.2.$explanation.a"><span data-reactid=".2cwjy2rb1mo.2.$explanation.a.0">There we go. </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.a.1">x</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.a.2">/</span><i data-reactid=".2cwjy2rb1mo.2.$explanation.a.3">y</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.a.4"> coordinates, linked through some mystery value </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.a.5">t</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.a.6">.</span></p><p data-reactid=".2cwjy2rb1mo.2.$explanation.b"><span data-reactid=".2cwjy2rb1mo.2.$explanation.b.0">So, parametric curves don&#x27;t define a </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.b.1">y</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.b.2"> coordinate in terms of an </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.b.3">x</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.b.4"> coordinate, like normal functions do, but they instead link the values to a &quot;control&quot; variable. If we vary the value of </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.b.5">t</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.b.6">, then with every change we get </span><strong data-reactid=".2cwjy2rb1mo.2.$explanation.b.7">two</strong><span data-reactid=".2cwjy2rb1mo.2.$explanation.b.8"> values, which we can use as (</span><i data-reactid=".2cwjy2rb1mo.2.$explanation.b.9">x</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.b.a">,</span><i data-reactid=".2cwjy2rb1mo.2.$explanation.b.b">y</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.b.c">) coordinates in a graph. The above set of functions, for instance, generates points on a circle: We can range </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.b.d">t</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.b.e"> from negative to positive infinity, and the resulting (</span><i data-reactid=".2cwjy2rb1mo.2.$explanation.b.f">x</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.b.g">,</span><i data-reactid=".2cwjy2rb1mo.2.$explanation.b.h">y</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.b.i">) coordinates will always lie on a circle with radius 1 around the origin (0,0). If we plot it for </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.b.j">t</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.b.k"> from 0 to 5, we get this (use your up and down arrow keys to change the plot end value):</span></p><figure class="false" data-reactid=".2cwjy2rb1mo.2.$explanation.c"><canvas tabindex="0" data-reactid=".2cwjy2rb1mo.2.$explanation.c.0"></canvas><figcaption data-reactid=".2cwjy2rb1mo.2.$explanation.c.1"><span data-reactid=".2cwjy2rb1mo.2.$explanation.c.1.0">A (partial) circle: x=sin(t), y=cos(t)</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.c.1.1"> </span></figcaption></figure><p data-reactid=".2cwjy2rb1mo.2.$explanation.d"><span data-reactid=".2cwjy2rb1mo.2.$explanation.d.0">Bézier curves are (one in many classes of) parametric functions, and are characterised by using the same base function for all its dimensions. Unlike the above example, where the </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.d.1">x</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.d.2"> and </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.d.3">y</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.d.4"> values use different functions (one uses a sine, the other a cosine), Bézier curves use the &quot;binomial polynomial&quot; for both </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.d.5">x</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.d.6"> and </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.d.7">y</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.d.8">. So what are binomial polynomials?</span></p><p data-reactid=".2cwjy2rb1mo.2.$explanation.e">You may remember polynomials from high school, where they&#x27;re those sums that look like:</p><p data-reactid=".2cwjy2rb1mo.2.$explanation.f"><img class="LaTeX SVG" src="images/latex/3e8b26cf8833db7089d65e9c6b3953a3140bb19f.svg" style="width:14.32485rem;height:1.20015rem;" data-reactid=".2cwjy2rb1mo.2.$explanation.f.0"/></p><p data-reactid=".2cwjy2rb1mo.2.$explanation.g"><span data-reactid=".2cwjy2rb1mo.2.$explanation.g.0">If they have a highest order term </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.g.1">x³</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.g.2"> they&#x27;re called &quot;cubic&quot; polynomials, if it&#x27;s</span><i data-reactid=".2cwjy2rb1mo.2.$explanation.g.3">x²</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.g.4"> it&#x27;s a &quot;square&quot; polynomial, if it&#x27;s just </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.g.5">x</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.g.6"> it&#x27;s a line (and if there aren&#x27;t even any terms with </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.g.7">x</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.g.8"> it&#x27;s not a polynomial!)</span></p><p data-reactid=".2cwjy2rb1mo.2.$explanation.h"><span data-reactid=".2cwjy2rb1mo.2.$explanation.h.0">Bézier curves are polynomials of </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.h.1">t</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.h.2">, rather than </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.h.3">x</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.h.4">, with the value for </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.h.5">t</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.h.6">fixed being between 0 and 1, with coefficients </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.h.7">a</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.h.8">, </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.h.9">b</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.h.a"> etc. taking the &quot;binomial&quot; form, which sounds fancy but is actually a pretty simple description for mixing values:</span></p><p data-reactid=".2cwjy2rb1mo.2.$explanation.i"><img class="LaTeX SVG" src="images/latex/24e915ab4c69b85951f1ea9018b0ece9e52a10dd.svg" style="width:24.89985rem;height:4.1998500000000005rem;" data-reactid=".2cwjy2rb1mo.2.$explanation.i.0"/></p><p data-reactid=".2cwjy2rb1mo.2.$explanation.j"><span data-reactid=".2cwjy2rb1mo.2.$explanation.j.0">I know what you&#x27;re thinking: that doesn&#x27;t look too simple, but if we remove </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.j.1">t</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.j.2"> and add in &quot;times one&quot;, things suddenly look pretty easy. Check out these binomial terms:</span></p><p data-reactid=".2cwjy2rb1mo.2.$explanation.k"><img class="LaTeX SVG" src="images/latex/448d10d21afd49135055cf685fedf6c494984b53.svg" style="width:14.475150000000001rem;height:5.175rem;" data-reactid=".2cwjy2rb1mo.2.$explanation.k.0"/></p><p data-reactid=".2cwjy2rb1mo.2.$explanation.l"><span data-reactid=".2cwjy2rb1mo.2.$explanation.l.0">Notice that 2 is the same as 1+1, and 3 is 2+1 and 1+2, and 6 is 3+3... As you can see, each time we go up a dimension, we simply start and end with 1, and everything in between is just &quot;the two numbers above it, added together&quot;. Now </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.l.1">that&#x27;s</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.l.2"> easy to remember.</span></p><p data-reactid=".2cwjy2rb1mo.2.$explanation.m"><span data-reactid=".2cwjy2rb1mo.2.$explanation.m.0">There&#x27;s an equally simple way to figure out how the polynomial terms work: if we rename </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.m.1">(1-t)</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.m.2"> to </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.m.3">a</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.m.4"> and </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.m.5">t</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.m.6"> to </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.m.7">b</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.m.8">, and remove the weights for a moment, we get this:</span></p><p data-reactid=".2cwjy2rb1mo.2.$explanation.n"><img class="LaTeX SVG" src="images/latex/87c7f5294b902def4ea56e8f6cf24265a37143b6.svg" style="width:20.84985rem;height:3.825rem;" data-reactid=".2cwjy2rb1mo.2.$explanation.n.0"/></p><p data-reactid=".2cwjy2rb1mo.2.$explanation.o"><span data-reactid=".2cwjy2rb1mo.2.$explanation.o.0">It&#x27;s basically just a sum of &quot;every combination of </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.o.1">a</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.o.2"> and </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.o.3">b</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.o.4">&quot;, progressively replacing </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.o.5">a</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.o.6">&#x27;s with </span><i data-reactid=".2cwjy2rb1mo.2.$explanation.o.7">b</i><span data-reactid=".2cwjy2rb1mo.2.$explanation.o.8">&#x27;s after every + sign. So that&#x27;s actually pretty simple too. So now you know binomial polynomials, and just for completeness I&#x27;m going to show you the generic function for this:</span></p><p data-reactid=".2cwjy2rb1mo.2.$explanation.p"><img class="LaTeX SVG" src="images/latex/d79bf595a0911c17e2ac86d8806a0a8ab6ba7dfe.svg" style="width:20.39985rem;height:3.90015rem;" data-reactid=".2cwjy2rb1mo.2.$explanation.p.0"/></p><p data-reactid=".2cwjy2rb1mo.2.$explanation.q">And that&#x27;s the full description for Bézier curves. Σ in this function indicates that this is a series of additions (using the variable listed below the Σ, starting at ...=&lt;value&gt; and ending at the value listed on top of the Σ).</p><div class="howtocode" data-reactid=".2cwjy2rb1mo.2.$explanation.r"><h3 data-reactid=".2cwjy2rb1mo.2.$explanation.r.0">How to implement the basis function</h3><p data-reactid=".2cwjy2rb1mo.2.$explanation.r.1">We could naively implement the basis function as a mathematical construct, using the function as our guide, like this:</p><pre data-reactid=".2cwjy2rb1mo.2.$explanation.r.2"><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.2.0">function Bezier(n,t):</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.2.1">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.2.2">  sum = 0</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.2.3">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.2.4">  for(k=0; k&lt;n; k++):</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.2.5">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.2.6">    sum += n!/(k!*(n-k)!) * (1-t)^(n-k) * t^(k)</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.2.7">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.2.8">  return sum</span></pre><p data-reactid=".2cwjy2rb1mo.2.$explanation.r.3"><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.3.0">I say we could, because we&#x27;re not going to: the factorial function is </span><em data-reactid=".2cwjy2rb1mo.2.$explanation.r.3.1">incredibly</em><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.3.2">expensive. And, as we can see from the above explanation, we can actually create Pascal&#x27;s triangle quite easily without it: just start at [1], then [1,1], then [1,2,1], then [1,3,3,1], and so on, with each next row fitting 1 more number than the previous row, starting and ending with &quot;1&quot;, with all the numbers in between being the sum of the previous row&#x27;s elements on either side &quot;above&quot; the one we&#x27;re computing.</span></p><p data-reactid=".2cwjy2rb1mo.2.$explanation.r.4">We can generate this as a list of lists lightning fast, and then never have to compute the binomial terms because we have a lookup table:</p><pre data-reactid=".2cwjy2rb1mo.2.$explanation.r.5"><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.0">lut = [      [1],           // n=0</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.1">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.2">            [1,1],          // n=1</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.3">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.4">           [1,2,1],         // n=2</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.5">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.6">          [1,3,3,1],        // n=3</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.7">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.8">         [1,4,6,4,1],       // n=4</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.9">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.a">        [1,5,10,10,5,1],    // n=5</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.b">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.c">       [1,6,15,20,15,6,1]]  // n=6</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.d">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.e">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.f">binomial(n,k):</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.g">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.h">  while(n &gt;= lut.length):</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.i">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.j">    s = lut.length</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.k">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.l">    nextRow = new array(size=s+1)</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.m">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.n">    nextRow[0] = 1</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.o">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.p">    for(i=1, prev=s-1; i&amp;ltprev; i++):</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.q">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.r">      nextRow[i] = lut[prev][i-1] + lut[prev][i]</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.s">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.t">    nextRow[s] = 1</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.u">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.v">    lut.add(nextRow)</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.w">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.5.x">  return lut[n][k]</span></pre><p data-reactid=".2cwjy2rb1mo.2.$explanation.r.6">So what&#x27;s going on here? First, we declare a lookup table with a size that&#x27;s reasonably large enough to accommodate most lookups. Then, we declare a function to get us the values we need, and we make sure that if an n/k pair is requested that isn&#x27;t in the LUT yet, we expand it first. Our basis function now looks like this:</p><pre data-reactid=".2cwjy2rb1mo.2.$explanation.r.7"><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.7.0">function Bezier(n,t):</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.7.1">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.7.2">  sum = 0</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.7.3">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.7.4">  for(k=0; k&lt;n; k++):</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.7.5">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.7.6">    sum += binomial(n,k) * (1-t)^(n-k) * t^(k)</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.7.7">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.7.8">  return sum</span></pre><p data-reactid=".2cwjy2rb1mo.2.$explanation.r.8">Perfect. Of course, we can optimize further. For most computer graphics purposes, we don&#x27;t need arbitrary curves. We need quadratic and  cubic curves (this primer actually does do arbitrary curves, so you&#x27;ll find code similar to shown here), which means we can drastically simplify the code:</p><pre data-reactid=".2cwjy2rb1mo.2.$explanation.r.9"><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.9.0">function Bezier(2,t):</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.9.1">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.9.2">  t2 = t * t</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.9.3">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.9.4">  mt = 1-t</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.9.5">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.9.6">  mt2 = mt * mt</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.9.7">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.9.8">  return mt2 + 2*mt*t + t2</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.9.9">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.9.a">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.9.b">function Bezier(3,t):</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.9.c">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.9.d">  t2 = t * t</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.9.e">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.9.f">  t3 = t2 * t</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.9.g">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.9.h">  mt = 1-t</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.9.i">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.9.j">  mt2 = mt * mt</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.9.k">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.9.l">  mt3 = mt2 * mt</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.9.m">
</span><span data-reactid=".2cwjy2rb1mo.2.$explanation.r.9.n">  return mt3 + 3*mt2*t + 3*mt*t2 + t3</span></pre><p data-reactid=".2cwjy2rb1mo.2.$explanation.r.a">And now we know how to program the basis function. Exellent.</p></div><p data-reactid=".2cwjy2rb1mo.2.$explanation.s">So, now we know what the base function(s) look(s) like, time to add in the magic that makes Bézier curves so special: control points.</p></section><table class="relatives after" data-reactid=".2cwjy2rb1mo.2.2"><tbody data-reactid=".2cwjy2rb1mo.2.2.0"><tr data-reactid=".2cwjy2rb1mo.2.2.0.0"><td data-reactid=".2cwjy2rb1mo.2.2.0.0.0"><a class="prev" href="whatis" data-reactid=".2cwjy2rb1mo.2.2.0.0.0.0">2. So what makes a Bézier Curve?</a></td><td class="toc" data-reactid=".2cwjy2rb1mo.2.2.0.0.1"><a class="" href="/" data-reactid=".2cwjy2rb1mo.2.2.0.0.1.0">ToC</a></td><td data-reactid=".2cwjy2rb1mo.2.2.0.0.2"><a class="next" href="control" data-reactid=".2cwjy2rb1mo.2.2.0.0.2.0">4. Controlling Bézier curvatures</a></td></tr></tbody></table></div><footer class="copyright" data-reactid=".2cwjy2rb1mo.3"><span data-reactid=".2cwjy2rb1mo.3.0">This article is © 2011-2016 to me, Mike &quot;Pomax&quot; Kamermans, but the text, code, and images are </span><a href="https://github.com/Pomax/bezierinfo/blob/gh-pages/LICENSE.md" data-reactid=".2cwjy2rb1mo.3.1">almost no rights reserved</a><span data-reactid=".2cwjy2rb1mo.3.2">. Go do something cool with it!</span></footer></div>
</body>
</html>