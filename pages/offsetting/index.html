<!doctype html>
<html>
<head>
<meta charset='utf-8'>
<title>
Curve offsetting
</title>
<base href='..'>
</head>
<body>
<div data-reactid=".gxyrhfkcn4" data-react-checksum="-967706530"><div class="ribbon" data-reactid=".gxyrhfkcn4.0"><img src="images/ribbon.png" alt="This page on GitHub" usemap="#githubmap" width="200px" height="149px" data-reactid=".gxyrhfkcn4.0.0"/><map name="githubmap" data-reactid=".gxyrhfkcn4.0.1"><area shape="poly" coords="30,0, 200,0, 200,114" href="http://github.com/pomax/BezierInfo-2" alt="This page on GitHub" data-reactid=".gxyrhfkcn4.0.1.0"/></map></div><header data-reactid=".gxyrhfkcn4.1"><h1 data-reactid=".gxyrhfkcn4.1.0">A Primer on Bézier Curves</h1><h2 data-reactid=".gxyrhfkcn4.1.1">A free, online book for when you really need to know how to do Bézier things.</h2></header><div data-reactid=".gxyrhfkcn4.2"><table class="relatives before" data-reactid=".gxyrhfkcn4.2.0"><tbody data-reactid=".gxyrhfkcn4.2.0.0"><tr data-reactid=".gxyrhfkcn4.2.0.0.0"><td data-reactid=".gxyrhfkcn4.2.0.0.0.0"><a class="prev" href="projections" data-reactid=".gxyrhfkcn4.2.0.0.0.0.0">31. Projecting a point onto a Bézier curve</a></td><td class="toc" data-reactid=".gxyrhfkcn4.2.0.0.0.1"><a class="" href="/" data-reactid=".gxyrhfkcn4.2.0.0.0.1.0">ToC</a></td><td data-reactid=".gxyrhfkcn4.2.0.0.0.2"><a class="next" href="graduatedoffset" data-reactid=".gxyrhfkcn4.2.0.0.0.2.0">33. Graduated curve offsetting</a></td></tr></tbody></table><section data-reactid=".gxyrhfkcn4.2.$offsetting"><h2 data-num="32" data-reactid=".gxyrhfkcn4.2.$offsetting.0"><a href="#offsetting" data-reactid=".gxyrhfkcn4.2.$offsetting.0.0">Curve offsetting</a></h2><p data-reactid=".gxyrhfkcn4.2.$offsetting.1">Perhaps you are like me, and you&#x27;ve been writing various small programs that use Bézier curves in some way or another, and at some point you make the step to implementing path extrusion. But you don&#x27;t want to do it pixel based, you want to stay in the vector world. You find that extruding lines is relatively easy, and tracing outlines is coming along nicely (although junction caps and fillets are a bit of a hassle), and then decide to do things properly and add Bézier curves to the mix. Now you have a problem.</p><p data-reactid=".gxyrhfkcn4.2.$offsetting.2">Unlike lines, you can&#x27;t simply extrude a Bézier curve by taking a copy and moving it around, because of the curvatures; rather than a uniform thickness you get an extrusion that looks too thin in places, if you&#x27;re lucky, but more likely will self-intersect. The trick, then, is to scale the curve, rather than simply copying it. But how do you scale a Bézier curve?</p><p data-reactid=".gxyrhfkcn4.2.$offsetting.3"><span data-reactid=".gxyrhfkcn4.2.$offsetting.3.0">Bottom line: </span><strong data-reactid=".gxyrhfkcn4.2.$offsetting.3.1">you can&#x27;t</strong><span data-reactid=".gxyrhfkcn4.2.$offsetting.3.2">. So you cheat. We&#x27;re not going to do true curve scaling, or rather curve offsetting, because that&#x27;s impossible. Instead we&#x27;re going to try to generate &#x27;looks good enough&#x27; offset curves.</span></p><div class="note" data-reactid=".gxyrhfkcn4.2.$offsetting.4"><h2 data-reactid=".gxyrhfkcn4.2.$offsetting.4.0">&quot;What do you mean, you can&#x27;t. Prove it.&quot;</h2><p data-reactid=".gxyrhfkcn4.2.$offsetting.4.1"><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.1.0">First off, when I say &quot;you can&#x27;t&quot; what I really mean is &quot;you can&#x27;t offset a Bézier curve with another Bézier curve&quot;. not even by using a really high order curve. You can find the function that describes the offset curve, but it won&#x27;t be a polynomial, and as such it cannot be represented as a Bézier curve, which</span><strong data-reactid=".gxyrhfkcn4.2.$offsetting.4.1.1">has</strong><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.1.2"> to be a polynomial. Let&#x27;s look at why this is:</span></p><p data-reactid=".gxyrhfkcn4.2.$offsetting.4.2"><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.2.0">From a mathematical point of view, an offset curve </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.2.1">O(t)</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.2.2"> is a curve such that, given our original curve</span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.2.3">B(t)</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.2.4">, any point on </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.2.5">O(t)</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.2.6"> is a fixed distance </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.2.7">d</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.2.8"> away from coordinate </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.2.9">B(t)</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.2.a">. So let&#x27;s math that:</span></p><p data-reactid=".gxyrhfkcn4.2.$offsetting.4.3"><img class="LaTeX SVG" src="images/latex/3aff5cef0028337bbb48ae64ad30000c4d5e238f.svg" style="width:7.275150000000001rem;height:1.125rem;" data-reactid=".gxyrhfkcn4.2.$offsetting.4.3.0"/></p><p data-reactid=".gxyrhfkcn4.2.$offsetting.4.4"><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.4.0">However, we&#x27;re working in 2D, and </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.4.1">d</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.4.2"> is a single value, so we want to turn it into a vector. If we want a point distance </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.4.3">d</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.4.4"> &quot;away&quot; from the curve </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.4.5">B(t)</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.4.6"> then what we really mean is that we want a point at </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.4.7">d</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.4.8"> times the &quot;normal vector&quot; from point </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.4.9">B(t)</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.4.a">, where the &quot;normal&quot; is a vector that runs perpendicular (&quot;at a right angle&quot;) to the tangent at </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.4.b">B(t)</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.4.c">. Easy enough:</span></p><p data-reactid=".gxyrhfkcn4.2.$offsetting.4.5"><img class="LaTeX SVG" src="images/latex/2cf48e2f8525258a3fa0fe4f10ec2acef67104b3.svg" style="width:10.125rem;height:1.125rem;" data-reactid=".gxyrhfkcn4.2.$offsetting.4.5.0"/></p><p data-reactid=".gxyrhfkcn4.2.$offsetting.4.6"><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.6.0">Now this still isn&#x27;t very useful unless we know what the formula for </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.6.1">N(t)</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.6.2"> is, so let&#x27;s find out.</span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.6.3">N(t)</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.6.4"> runs perpendicular to the original curve tangent, and we know that the tangent is simply</span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.6.5">B&#x27;(t)</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.6.6">, so we could just rotate that 90 degrees and be done with it. However, we need to ensure that </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.6.7">N(t)</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.6.8"> has the same magnitude for every </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.6.9">t</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.6.a">, or the offset curve won&#x27;t be at a uniform distance, thus not being an offset curve at all. The easiest way to guarantee this is to make sure</span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.6.b">N(t)</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.6.c"> always has length 1, which we can achieve by dividing </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.6.d">B&#x27;(t)</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.6.e"> by its magnitude:</span></p><p data-reactid=".gxyrhfkcn4.2.$offsetting.4.7"><img class="LaTeX SVG" src="images/latex/664fba98ea17b358941b579115bf063edf87ae17.svg" style="width:9.450000000000001rem;height:3.15rem;" data-reactid=".gxyrhfkcn4.2.$offsetting.4.7.0"/></p><p data-reactid=".gxyrhfkcn4.2.$offsetting.4.8"><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.8.0">Determining the length requires computing an arc length, and this is where things get Tricky with a capital T. First off, to compute arc length from some start </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.8.1">a</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.8.2"> to end </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.8.3">b</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.8.4">, we must use the formula we saw earlier. Noting that &quot;length&quot; is usually denoted with double vertical bars:</span></p><p data-reactid=".gxyrhfkcn4.2.$offsetting.4.9"><img class="LaTeX SVG" src="images/latex/f6d8c2965b02363e092acb00bbc1398cfbb170a4.svg" style="width:12.45015rem;height:2.6248500000000003rem;" data-reactid=".gxyrhfkcn4.2.$offsetting.4.9.0"/></p><p data-reactid=".gxyrhfkcn4.2.$offsetting.4.a"><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.a.0">So if we want the length of the tangent, we plug in </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.a.1">B&#x27;(t)</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.a.2">, with </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.a.3">t = 0</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.a.4"> as start and</span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.a.5">t = 1</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.a.6"> as end:</span></p><p data-reactid=".gxyrhfkcn4.2.$offsetting.4.b"><img class="LaTeX SVG" src="images/latex/1f024282044316a9e4b3de2c855d2ceb96aff056.svg" style="width:15.150150000000002rem;height:2.6248500000000003rem;" data-reactid=".gxyrhfkcn4.2.$offsetting.4.b.0"/></p><p data-reactid=".gxyrhfkcn4.2.$offsetting.4.c"><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.c.0">And that&#x27;s where things go wrong. It doesn&#x27;t even really matter what the second derivative for </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.c.1">B(t)</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.c.2">is, that square root is screwing everything up, because it turns our nice polynomials into things that are no longer polynomials.</span></p><p data-reactid=".gxyrhfkcn4.2.$offsetting.4.d"><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.d.0">There is a small class of polynomials where the square root is also a polynomial, but they&#x27;re utterly useless to us: any polynomial with unweighted binomial coefficients has a square root that is also a polynomial. Now, you might think that Bézier curves are just fine because they do, but they don&#x27;t; remember that only the </span><strong data-reactid=".gxyrhfkcn4.2.$offsetting.4.d.1">base</strong><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.d.2"> function has binomial coefficients. That&#x27;s before we factor in our coordinates, which turn it into a non-binomial polygon. The only way to make sure the functions stay binomial is to make all our coordinates have the same value. And that&#x27;s not a curve, that&#x27;s a point. We can already create offset curves for points, we call them circles, and they have much simpler functions than Bézier curves.</span></p><p data-reactid=".gxyrhfkcn4.2.$offsetting.4.e"><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.e.0">So, since the tangent length isn&#x27;t a polynomial, the normalised tangent won&#x27;t be a polynomial either, which means </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.e.1">N(t)</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.e.2"> won&#x27;t be a polynomial, which means that </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.e.3">d</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.e.4"> times </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.e.5">N(t)</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.e.6"> won&#x27;t be a polynomial, which means that, ultimately, </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.e.7">O(t)</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.e.8"> won&#x27;t be a polynomial, which means that even if we can determine the function for </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.e.9">O(t)</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.e.a"> just fine (and that&#x27;s far from trivial!), it simply cannot be represented as a Bézier curve.</span></p><p data-reactid=".gxyrhfkcn4.2.$offsetting.4.f"><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.f.0">And that&#x27;s one reason why Bézier curves are tricky: there are actually a </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.4.f.1">lot</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.4.f.2"> of curves that cannot be represent as a Bézier curve at all. They can&#x27;t even model their own offset curves. They&#x27;re weird that way. So how do all those other programs do it? Well, much like we&#x27;re about to do, they cheat. We&#x27;re going to approximate an offset curve in a way that will look relatively close to what the real offset curve would look like, if we could compute it.</span></p></div><p data-reactid=".gxyrhfkcn4.2.$offsetting.5"><span data-reactid=".gxyrhfkcn4.2.$offsetting.5.0">So, you cannot offset a Bézier curve perfectly with another Bézier curve, no matter how high-order you make that other Bézier curve. However, we can chop up a curve into &quot;safe&quot; sub-curves (where safe means that all the control points are always on a single side of the baseline, and the midpoint of the curve at </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.5.1">t=0.5</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.5.2"> is roughly in the centre of the polygon defined by the curve coordinates) and then point-scale those sub-curves with respect to the curve&#x27;s scaling origin (which is the intersection of the point normals at the start and end points).</span></p><p data-reactid=".gxyrhfkcn4.2.$offsetting.6"><span data-reactid=".gxyrhfkcn4.2.$offsetting.6.0">A good way to do this reduction is to first find the curve&#x27;s extreme points, as explained in the earlier section on curve extremities, and use these as initial splitting points. After this initial split, we can check each individual segment to see if it&#x27;s &quot;safe enough&quot; based on where the center of the curve is. If the on-curve point for </span><i data-reactid=".gxyrhfkcn4.2.$offsetting.6.1">t=0.5</i><span data-reactid=".gxyrhfkcn4.2.$offsetting.6.2"> is too far off from the center, we simply split the segment down the middle. Generally this is more than enough to end up with safe segments.</span></p><p data-reactid=".gxyrhfkcn4.2.$offsetting.7">The following graphics show off curve offsetting, and you can use your up and down arrow keys to control the distance at which the curve gets offset. The curve first gets reduced to safe segments, each of which is then offset at the desired distance. Especially for simple curves, particularly easily set up for quadratic curves, no reduction is necessary, but the more twisty the curve gets, the more the curve needs to be reduced in order to get segments that can safely be scaled.</p><figure class="false" data-reactid=".gxyrhfkcn4.2.$offsetting.8"><canvas tabindex="0" data-reactid=".gxyrhfkcn4.2.$offsetting.8.0"></canvas><figcaption data-reactid=".gxyrhfkcn4.2.$offsetting.8.1"><span data-reactid=".gxyrhfkcn4.2.$offsetting.8.1.0">Offsetting a quadratic Bézier curve</span><span data-reactid=".gxyrhfkcn4.2.$offsetting.8.1.1"> </span></figcaption></figure><figure class="false" data-reactid=".gxyrhfkcn4.2.$offsetting.9"><canvas tabindex="0" data-reactid=".gxyrhfkcn4.2.$offsetting.9.0"></canvas><figcaption data-reactid=".gxyrhfkcn4.2.$offsetting.9.1"><span data-reactid=".gxyrhfkcn4.2.$offsetting.9.1.0">Offsetting a cubic Bézier curve</span><span data-reactid=".gxyrhfkcn4.2.$offsetting.9.1.1"> </span></figcaption></figure><p data-reactid=".gxyrhfkcn4.2.$offsetting.a">You may notice that this may still lead to small &#x27;jumps&#x27; in the sub-curves when moving the curve around. This is caused by the fact that we&#x27;re still performing a naive form of offsetting, moving the control points the same distance as the start and end points. If the curve is large enough, this may still lead to incorrect offsets.</p></section><table class="relatives after" data-reactid=".gxyrhfkcn4.2.2"><tbody data-reactid=".gxyrhfkcn4.2.2.0"><tr data-reactid=".gxyrhfkcn4.2.2.0.0"><td data-reactid=".gxyrhfkcn4.2.2.0.0.0"><a class="prev" href="projections" data-reactid=".gxyrhfkcn4.2.2.0.0.0.0">31. Projecting a point onto a Bézier curve</a></td><td class="toc" data-reactid=".gxyrhfkcn4.2.2.0.0.1"><a class="" href="/" data-reactid=".gxyrhfkcn4.2.2.0.0.1.0">ToC</a></td><td data-reactid=".gxyrhfkcn4.2.2.0.0.2"><a class="next" href="graduatedoffset" data-reactid=".gxyrhfkcn4.2.2.0.0.2.0">33. Graduated curve offsetting</a></td></tr></tbody></table></div><footer class="copyright" data-reactid=".gxyrhfkcn4.3"><span data-reactid=".gxyrhfkcn4.3.0">This article is © 2011-2016 to me, Mike &quot;Pomax&quot; Kamermans, but the text, code, and images are </span><a href="https://github.com/Pomax/bezierinfo/blob/gh-pages/LICENSE.md" data-reactid=".gxyrhfkcn4.3.1">almost no rights reserved</a><span data-reactid=".gxyrhfkcn4.3.2">. Go do something cool with it!</span></footer></div>
</body>
</html>