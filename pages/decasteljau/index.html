<!doctype html>
<html>
<head>
<meta charset='utf-8'>
<title>
de Casteljau's algorithm
</title>
<base href='..'>
</head>
<body>
<div data-reactid=".s31m5666f4" data-react-checksum="-675499557"><div class="ribbon" data-reactid=".s31m5666f4.0"><img src="images/ribbon.png" alt="This page on GitHub" usemap="#githubmap" width="200px" height="149px" data-reactid=".s31m5666f4.0.0"/><map name="githubmap" data-reactid=".s31m5666f4.0.1"><area shape="poly" coords="30,0, 200,0, 200,114" href="http://github.com/pomax/BezierInfo-2" alt="This page on GitHub" data-reactid=".s31m5666f4.0.1.0"/></map></div><header data-reactid=".s31m5666f4.1"><h1 data-reactid=".s31m5666f4.1.0">A Primer on Bézier Curves</h1><h2 data-reactid=".s31m5666f4.1.1">A free, online book for when you really need to know how to do Bézier things.</h2></header><div data-reactid=".s31m5666f4.2"><table class="relatives before" data-reactid=".s31m5666f4.2.0"><tbody data-reactid=".s31m5666f4.2.0.0"><tr data-reactid=".s31m5666f4.2.0.0.0"><td data-reactid=".s31m5666f4.2.0.0.0.0"><a class="prev" href="matrix" data-reactid=".s31m5666f4.2.0.0.0.0.0">5. Bézier curvatures as matrix operations</a></td><td class="toc" data-reactid=".s31m5666f4.2.0.0.0.1"><a class="" href="/" data-reactid=".s31m5666f4.2.0.0.0.1.0">ToC</a></td><td data-reactid=".s31m5666f4.2.0.0.0.2"><a class="next" href="flattening" data-reactid=".s31m5666f4.2.0.0.0.2.0">7. Simplified drawing</a></td></tr></tbody></table><section data-reactid=".s31m5666f4.2.$decasteljau"><h2 data-num="6" data-reactid=".s31m5666f4.2.$decasteljau.0"><a href="#decasteljau" data-reactid=".s31m5666f4.2.$decasteljau.0.0">de Casteljau&#x27;s algorithm</a></h2><p data-reactid=".s31m5666f4.2.$decasteljau.1"><span data-reactid=".s31m5666f4.2.$decasteljau.1.0">If we want to draw Bézier curves we can run through all values of </span><i data-reactid=".s31m5666f4.2.$decasteljau.1.1">t</i><span data-reactid=".s31m5666f4.2.$decasteljau.1.2"> from 0 to 1 and then compute the weighted basis function, getting the </span><i data-reactid=".s31m5666f4.2.$decasteljau.1.3">x</i><span data-reactid=".s31m5666f4.2.$decasteljau.1.4">/</span><i data-reactid=".s31m5666f4.2.$decasteljau.1.5">y</i><span data-reactid=".s31m5666f4.2.$decasteljau.1.6"> values we need to plot, but the more complex the curve gets, the more expensive this becomes. Instead, we can use &quot;de Casteljau&#x27;s algorithm&quot; to draw curves, which is a geometric approach to drawing curves, and really easy to implement. So easy, in fact, you can do it by hand with a pencil and ruler.</span></p><p data-reactid=".s31m5666f4.2.$decasteljau.2"><span data-reactid=".s31m5666f4.2.$decasteljau.2.0">Rather than using our calculus function to find </span><i data-reactid=".s31m5666f4.2.$decasteljau.2.1">x</i><span data-reactid=".s31m5666f4.2.$decasteljau.2.2">/</span><i data-reactid=".s31m5666f4.2.$decasteljau.2.3">y</i><span data-reactid=".s31m5666f4.2.$decasteljau.2.4"> values for </span><i data-reactid=".s31m5666f4.2.$decasteljau.2.5">t</i><span data-reactid=".s31m5666f4.2.$decasteljau.2.6">, let&#x27;s do this instead:</span></p><ul data-reactid=".s31m5666f4.2.$decasteljau.3"><li data-reactid=".s31m5666f4.2.$decasteljau.3.0"><span data-reactid=".s31m5666f4.2.$decasteljau.3.0.0">treat </span><i data-reactid=".s31m5666f4.2.$decasteljau.3.0.1">t</i><span data-reactid=".s31m5666f4.2.$decasteljau.3.0.2"> as a ratio (which it is). t=0 is 0% along a line, t=1 is 100% along a line.</span></li><li data-reactid=".s31m5666f4.2.$decasteljau.3.1"><span data-reactid=".s31m5666f4.2.$decasteljau.3.1.0">Take all lines between the curve&#x27;s defining points. For an order </span><i data-reactid=".s31m5666f4.2.$decasteljau.3.1.1">n</i><span data-reactid=".s31m5666f4.2.$decasteljau.3.1.2"> curve, that&#x27;s </span><i data-reactid=".s31m5666f4.2.$decasteljau.3.1.3">n</i><span data-reactid=".s31m5666f4.2.$decasteljau.3.1.4"> lines.</span></li><li data-reactid=".s31m5666f4.2.$decasteljau.3.2"><span data-reactid=".s31m5666f4.2.$decasteljau.3.2.0">Place markers along each of these line, at distance </span><i data-reactid=".s31m5666f4.2.$decasteljau.3.2.1">t</i><span data-reactid=".s31m5666f4.2.$decasteljau.3.2.2">. So if </span><i data-reactid=".s31m5666f4.2.$decasteljau.3.2.3">t</i><span data-reactid=".s31m5666f4.2.$decasteljau.3.2.4"> is 0.2, place the mark at 20% from the start, 80% from the end.</span></li><li data-reactid=".s31m5666f4.2.$decasteljau.3.3"><span data-reactid=".s31m5666f4.2.$decasteljau.3.3.0">Now form lines between </span><i data-reactid=".s31m5666f4.2.$decasteljau.3.3.1">those</i><span data-reactid=".s31m5666f4.2.$decasteljau.3.3.2"> points. This gives </span><i data-reactid=".s31m5666f4.2.$decasteljau.3.3.3">n-1</i><span data-reactid=".s31m5666f4.2.$decasteljau.3.3.4"> lines.</span></li><li data-reactid=".s31m5666f4.2.$decasteljau.3.4"><span data-reactid=".s31m5666f4.2.$decasteljau.3.4.0">Place markers along each of these line at distance </span><i data-reactid=".s31m5666f4.2.$decasteljau.3.4.1">t</i><span data-reactid=".s31m5666f4.2.$decasteljau.3.4.2">.</span></li><li data-reactid=".s31m5666f4.2.$decasteljau.3.5"><span data-reactid=".s31m5666f4.2.$decasteljau.3.5.0">Form lines between </span><i data-reactid=".s31m5666f4.2.$decasteljau.3.5.1">those</i><span data-reactid=".s31m5666f4.2.$decasteljau.3.5.2"> points. This&#x27;ll be </span><i data-reactid=".s31m5666f4.2.$decasteljau.3.5.3">n-2</i><span data-reactid=".s31m5666f4.2.$decasteljau.3.5.4"> lines.</span></li><li data-reactid=".s31m5666f4.2.$decasteljau.3.6">place markers, form lines, place markers, etc.</li><li data-reactid=".s31m5666f4.2.$decasteljau.3.7"><span data-reactid=".s31m5666f4.2.$decasteljau.3.7.0">repeat this until you have only one line left. The point </span><i data-reactid=".s31m5666f4.2.$decasteljau.3.7.1">t</i><span data-reactid=".s31m5666f4.2.$decasteljau.3.7.2"> on that line coincides with the original curve point at </span><i data-reactid=".s31m5666f4.2.$decasteljau.3.7.3">t</i><span data-reactid=".s31m5666f4.2.$decasteljau.3.7.4">.</span></li></ul><div class="howtocode" data-reactid=".s31m5666f4.2.$decasteljau.4"><h3 data-reactid=".s31m5666f4.2.$decasteljau.4.0">How to implement de Casteljau&#x27;s algorithm</h3><p data-reactid=".s31m5666f4.2.$decasteljau.4.1">Let&#x27;s just use the algorithm we just specified, and implement that:</p><pre data-reactid=".s31m5666f4.2.$decasteljau.4.2"><span data-reactid=".s31m5666f4.2.$decasteljau.4.2.0">function drawCurve(points[], t):</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.2.1">
</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.2.2">  if(points.length==1):</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.2.3">
</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.2.4">    draw(points[0])</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.2.5">
</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.2.6">  else:</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.2.7">
</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.2.8">    newpoints=array(points.size-1)</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.2.9">
</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.2.a">    for(i=0; i&lt;newpoints.length; i++):</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.2.b">
</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.2.c">      newpoints[i] = (1-t) * points[i] + t * points[i+1]</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.2.d">
</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.2.e">    drawCurve(newpoints, t)</span></pre><p data-reactid=".s31m5666f4.2.$decasteljau.4.3"><span data-reactid=".s31m5666f4.2.$decasteljau.4.3.0">And done, that&#x27;s the algorithm implemented. Except usually you don&#x27;t get the luxury of overloading the &quot;+&quot; operator, so let&#x27;s also give the code for when you need to work with</span><i data-reactid=".s31m5666f4.2.$decasteljau.4.3.1">x</i><span data-reactid=".s31m5666f4.2.$decasteljau.4.3.2"> and </span><i data-reactid=".s31m5666f4.2.$decasteljau.4.3.3">y</i><span data-reactid=".s31m5666f4.2.$decasteljau.4.3.4"> values:</span></p><pre data-reactid=".s31m5666f4.2.$decasteljau.4.4"><span data-reactid=".s31m5666f4.2.$decasteljau.4.4.0">function drawCurve(points[], t):</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.4.1">
</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.4.2">  if(points.length==1):</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.4.3">
</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.4.4">    draw(points[0])</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.4.5">
</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.4.6">  else:</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.4.7">
</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.4.8">    newpoints=array(points.size-1)</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.4.9">
</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.4.a">    for(i=0; i&lt;newpoints.length; i++):</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.4.b">
</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.4.c">      x = (1-t) * points[i].x + t * points[i+1].x</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.4.d">
</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.4.e">      y = (1-t) * points[i].y + t * points[i+1].y</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.4.f">
</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.4.g">      newpoints[i] = new point(x,y)</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.4.h">
</span><span data-reactid=".s31m5666f4.2.$decasteljau.4.4.i">    drawCurve(newpoints, t)</span></pre><p data-reactid=".s31m5666f4.2.$decasteljau.4.5"><span data-reactid=".s31m5666f4.2.$decasteljau.4.5.0">So what does this do? This draws a point, if the passed list of points is only 1 point long. Otherwise it will create a new list of points that sit at the </span><i data-reactid=".s31m5666f4.2.$decasteljau.4.5.1">t</i><span data-reactid=".s31m5666f4.2.$decasteljau.4.5.2"> ratios (i.e. the &quot;markers&quot; outlined in the above algorithm), and then call the draw function for this new list.</span></p></div><p data-reactid=".s31m5666f4.2.$decasteljau.5">To see this in action, mouse-over the following sketch. Moving the mouse changes which curve point is explicitly evaluated using de Casteljau&#x27;s algorithm, moving the cursor left-to-right (or, of course, right-to-left), shows you how a curve is generated using this approach.</p><figure class="false" data-reactid=".s31m5666f4.2.$decasteljau.6"><canvas tabindex="0" data-reactid=".s31m5666f4.2.$decasteljau.6.0"></canvas><figcaption data-reactid=".s31m5666f4.2.$decasteljau.6.1"><span data-reactid=".s31m5666f4.2.$decasteljau.6.1.0">Traversing a curve using de Casteljau&#x27;s algorithm</span><span data-reactid=".s31m5666f4.2.$decasteljau.6.1.1"> </span></figcaption></figure></section><table class="relatives after" data-reactid=".s31m5666f4.2.2"><tbody data-reactid=".s31m5666f4.2.2.0"><tr data-reactid=".s31m5666f4.2.2.0.0"><td data-reactid=".s31m5666f4.2.2.0.0.0"><a class="prev" href="matrix" data-reactid=".s31m5666f4.2.2.0.0.0.0">5. Bézier curvatures as matrix operations</a></td><td class="toc" data-reactid=".s31m5666f4.2.2.0.0.1"><a class="" href="/" data-reactid=".s31m5666f4.2.2.0.0.1.0">ToC</a></td><td data-reactid=".s31m5666f4.2.2.0.0.2"><a class="next" href="flattening" data-reactid=".s31m5666f4.2.2.0.0.2.0">7. Simplified drawing</a></td></tr></tbody></table></div><footer class="copyright" data-reactid=".s31m5666f4.3"><span data-reactid=".s31m5666f4.3.0">This article is © 2011-2016 to me, Mike &quot;Pomax&quot; Kamermans, but the text, code, and images are </span><a href="https://github.com/Pomax/bezierinfo/blob/gh-pages/LICENSE.md" data-reactid=".s31m5666f4.3.1">almost no rights reserved</a><span data-reactid=".s31m5666f4.3.2">. Go do something cool with it!</span></footer></div>
</body>
</html>