<!doctype html>
<html>
<head>
<meta charset='utf-8'>
<title>
Canonical form (for cubic curves)
</title>
<base href='..'>
</head>
<body>
<div data-reactid=".ku3c6u2igw" data-react-checksum="985625745"><div class="ribbon" data-reactid=".ku3c6u2igw.0"><img src="images/ribbon.png" alt="This page on GitHub" usemap="#githubmap" width="200px" height="149px" data-reactid=".ku3c6u2igw.0.0"/><map name="githubmap" data-reactid=".ku3c6u2igw.0.1"><area shape="poly" coords="30,0, 200,0, 200,114" href="http://github.com/pomax/BezierInfo-2" alt="This page on GitHub" data-reactid=".ku3c6u2igw.0.1.0"/></map></div><header data-reactid=".ku3c6u2igw.1"><h1 data-reactid=".ku3c6u2igw.1.0">A Primer on Bézier Curves</h1><h2 data-reactid=".ku3c6u2igw.1.1">A free, online book for when you really need to know how to do Bézier things.</h2></header><div data-reactid=".ku3c6u2igw.2"><table class="relatives before" data-reactid=".ku3c6u2igw.2.0"><tbody data-reactid=".ku3c6u2igw.2.0.0"><tr data-reactid=".ku3c6u2igw.2.0.0.0"><td data-reactid=".ku3c6u2igw.2.0.0.0.0"><a class="prev" href="tightbounds" data-reactid=".ku3c6u2igw.2.0.0.0.0.0">17. Tight boxes</a></td><td class="toc" data-reactid=".ku3c6u2igw.2.0.0.0.1"><a class="" href="/" data-reactid=".ku3c6u2igw.2.0.0.0.1.0">ToC</a></td><td data-reactid=".ku3c6u2igw.2.0.0.0.2"><a class="next" href="arclength" data-reactid=".ku3c6u2igw.2.0.0.0.2.0">19. Arc length</a></td></tr></tbody></table><section data-reactid=".ku3c6u2igw.2.$canonical"><h2 data-num="18" data-reactid=".ku3c6u2igw.2.$canonical.0"><a href="#canonical" data-reactid=".ku3c6u2igw.2.$canonical.0.0">Canonical form (for cubic curves)</a></h2><p data-reactid=".ku3c6u2igw.2.$canonical.1">While quadratic curves are relatively simple curves to analyze, the same cannot be said of the cubic curve. As a curvature controlled by more than one control points, it exhibits all kinds of features like loops, cusps, odd colinear features, and up to two inflection points because the curvature can change direction up to three times. Now, knowing what kind of curve we&#x27;re dealing with means that some algorithms can be run more efficiently than if we have to implement them as generic solvers, so is there a way to determine the curve type without lots of work?</p><p data-reactid=".ku3c6u2igw.2.$canonical.2"><span data-reactid=".ku3c6u2igw.2.$canonical.2.0">As it so happens, the answer is yes and the solution we&#x27;re going to look at was presented by Maureen C. Stone from Xerox PARC and Tony D. deRose from the University of Washington in their joint paper</span><a href="http://graphics.pixar.com/people/derose/publications/CubicClassification/paper.pdf" data-reactid=".ku3c6u2igw.2.$canonical.2.1">&quot;A Geometric Characterization of Parametric Cubic curves&quot;</a><span data-reactid=".ku3c6u2igw.2.$canonical.2.2">. It was published in 1989, and defines curves as having a &quot;canonical&quot; form (i.e. a form that all curves can be reduced to) from which we can immediately tell which features a curve will have. So how does it work?</span></p><p data-reactid=".ku3c6u2igw.2.$canonical.3">The first observation that makes things work is that if we have a cubic curve with four points, we can apply a linear transformation to these points such that three of the points end up on (0,0), (0,1) and (1,1), with the last point then being &quot;somewhere&quot;. After applying that transformation, the location of that last point can then tell us what kind of curve we&#x27;re dealing with. Specifically, we see the following breakdown:</p><figure class="false" data-reactid=".ku3c6u2igw.2.$canonical.4"><canvas tabindex="0" data-reactid=".ku3c6u2igw.2.$canonical.4.0"></canvas><figcaption data-reactid=".ku3c6u2igw.2.$canonical.4.1"><span data-reactid=".ku3c6u2igw.2.$canonical.4.1.0">The canonical curve map</span><span data-reactid=".ku3c6u2igw.2.$canonical.4.1.1"> </span></figcaption></figure><p data-reactid=".ku3c6u2igw.2.$canonical.5">This is a fairly funky image, so let&#x27;s see how it breaks down. We see the three fixed points at (0,0), (0,1) and (1,1), and then the fourth point is somewhere. Depending on where it is, our curve will have certain features. Namely, if the fourth point is...</p><ol data-reactid=".ku3c6u2igw.2.$canonical.6"><li data-reactid=".ku3c6u2igw.2.$canonical.6.0"><span data-reactid=".ku3c6u2igw.2.$canonical.6.0.0">anywhere on and in the red zone, the curve will be self-intersecting, yielding either a cusp or a loop. Anywhere inside the the red zone, this will be a loop. We won&#x27;t know </span><i data-reactid=".ku3c6u2igw.2.$canonical.6.0.1">where</i><span data-reactid=".ku3c6u2igw.2.$canonical.6.0.2"> that loop is (in terms of </span><i data-reactid=".ku3c6u2igw.2.$canonical.6.0.3">t</i><span data-reactid=".ku3c6u2igw.2.$canonical.6.0.4"> values), but we are guaranteed that there is one.</span></li><li data-reactid=".ku3c6u2igw.2.$canonical.6.1"><span data-reactid=".ku3c6u2igw.2.$canonical.6.1.0">on the left (red) edge, the curve will have a cusp. We again don&#x27;t know </span><em data-reactid=".ku3c6u2igw.2.$canonical.6.1.1">where</em><span data-reactid=".ku3c6u2igw.2.$canonical.6.1.2">, just that it has one. This edge is described by the function: </span><img class="LaTeX SVG" src="images/latex/ae5a63e86bb367e6266a394962387344d0a92b10.svg" style="width:12.45015rem;height:2.3998500000000003rem;" data-reactid=".ku3c6u2igw.2.$canonical.6.1.3"/></li><li data-reactid=".ku3c6u2igw.2.$canonical.6.2"><span data-reactid=".ku3c6u2igw.2.$canonical.6.2.0">on the lower right (pink) edge, the curve will have a loop at t=1, so we know the end coordinate of the curve also lies </span><em data-reactid=".ku3c6u2igw.2.$canonical.6.2.1">on</em><span data-reactid=".ku3c6u2igw.2.$canonical.6.2.2"> the curve. This edge is described by the function: </span><img class="LaTeX SVG" src="images/latex/d389fcde05a773be99f84db5fc9ed7ef043bf406.svg" style="width:16.050150000000002rem;height:2.6248500000000003rem;" data-reactid=".ku3c6u2igw.2.$canonical.6.2.3"/></li><li data-reactid=".ku3c6u2igw.2.$canonical.6.3"><span data-reactid=".ku3c6u2igw.2.$canonical.6.3.0">on the top (blue) edge, the curve will have a loop at t=0, so we know the start coordinate of the curve also lies </span><em data-reactid=".ku3c6u2igw.2.$canonical.6.3.1">on</em><span data-reactid=".ku3c6u2igw.2.$canonical.6.3.2"> the curve. This edge is described by the function: </span><img class="LaTeX SVG" src="images/latex/d97181a9d0ada19862a0ff2cebb08bdee00868d7.svg" style="width:10.650150000000002rem;height:2.3998500000000003rem;" data-reactid=".ku3c6u2igw.2.$canonical.6.3.3"/></li><li data-reactid=".ku3c6u2igw.2.$canonical.6.4">inside the green zone, the curve will have a single inflection, switching concave/convex once.</li><li data-reactid=".ku3c6u2igw.2.$canonical.6.5">between the red and green zones, the curve has two inflections, meaning its curvature switches between concave/convex form twice.</li><li data-reactid=".ku3c6u2igw.2.$canonical.6.6">anywhere on the right of the red zone, the curve will have no inflections. It&#x27;ll just be a well-behaved arch.</li></ol><p data-reactid=".ku3c6u2igw.2.$canonical.7">Of course, this map is fairly small, but the regions extend to infinity, with well defined boundaries.</p><div class="note" data-reactid=".ku3c6u2igw.2.$canonical.8"><h3 data-reactid=".ku3c6u2igw.2.$canonical.8.0">Wait, where do those lines come from?</h3><p data-reactid=".ku3c6u2igw.2.$canonical.8.1">Without repeating the paper mentioned at the top of this section, the loop-boundaries come from rewriting the curve into canonical form, and then solving the formulae for which constraints must hold for which possible curve properties. In the paper these functions yield formulae for where you will find cusp points, or loops where we know t=0 or t=1, but those functions are derived for the full cubic expression, meaning they apply to t=-∞ to t=∞... For Bézier curves we only care about the &quot;clipped interval&quot; t=0 to t=1, so some of the properties that apply when you look at the curve over an infinite interval simply don&#x27;t apply to the Bézier curve interval.</p><p data-reactid=".ku3c6u2igw.2.$canonical.8.2">The right bound for the loop region, indicating where the curve switches from &quot;having inflections&quot; to &quot;having a loop&quot;, for the general cubic curve, is actually mirrored over x=1, but for Bézier curves this right half doesn&#x27;t apply, so we don&#x27;t need to pay attention to it. Similarly, the boundaries for t=0 and t=1 loops are also nice clean curves but get &quot;cut off&quot; when we only look at what the general curve does over the interval t=0 to t=1.</p><p data-reactid=".ku3c6u2igw.2.$canonical.8.3">For the full details, head over to the paper and read through sections 3 and 4. If you still remember your high school precalculus, you can probably follow along with this paper, although you might have to read it a few times before all the bits &quot;click&quot;.</p></div><p data-reactid=".ku3c6u2igw.2.$canonical.9">So now the question becomes: how do we manipulate our curve so that it fits this canonical form, with three fixed points, and one &quot;free&quot; point? Enter linear algerba. Don&#x27;t worry, I&#x27;ll be doing all the math for you, as well as show you what the effect is on our curves, but basically we&#x27;re going to be using linear algebra, rather than calculus, because &quot;it&#x27;s way easier&quot;. Sometimes a calculus approach is very hard to work with, when the equivalent geometrical solution is super obvious.</p><p data-reactid=".ku3c6u2igw.2.$canonical.a">The approach is going to start with a curve that doesn&#x27;t have all-colinear points (so we need to make sure the points don&#x27;t all fall on a straight line), and then applying four graphics operations that you will probably have heard of: translation (moving all points by some fixed x- and y-distance), scaling (multiplying all points by some x and y scale factor), and shearing (an operation that turns rectangles into parallelograms).</p><p data-reactid=".ku3c6u2igw.2.$canonical.b"><span data-reactid=".ku3c6u2igw.2.$canonical.b.0">Step 1: we translate any curve by -p1.x and -p1.y, so that the curve starts at (0,0). We&#x27;re going to make use of an interesting trick here, by pretending our 2D coordinates are 3D, with the </span><i data-reactid=".ku3c6u2igw.2.$canonical.b.1">z</i><span data-reactid=".ku3c6u2igw.2.$canonical.b.2">coordinate simply always being 1. This is an old trick in graphics to overcome the limitations of 2D transformations: without it, we can only turn (x,y) coordinates into new coordinates of the form (ax + by, cx + dy), which means we can&#x27;t do translation, since that requires we end up with some kind of (x + a, y + b). If we add a bogus </span><i data-reactid=".ku3c6u2igw.2.$canonical.b.3">z</i><span data-reactid=".ku3c6u2igw.2.$canonical.b.4"> coordinate that is always 1, then we can suddenly add arbitrary values. For example:</span></p><p data-reactid=".ku3c6u2igw.2.$canonical.c"><img class="LaTeX SVG" src="images/latex/cc3850bd6d6ab81fa414e81f54d4d4e53bcf69c8.svg" style="width:34.05015rem;height:4.05rem;" data-reactid=".ku3c6u2igw.2.$canonical.c.0"/></p><p data-reactid=".ku3c6u2igw.2.$canonical.d"><span data-reactid=".ku3c6u2igw.2.$canonical.d.0">Sweet! </span><i data-reactid=".ku3c6u2igw.2.$canonical.d.1">z</i><span data-reactid=".ku3c6u2igw.2.$canonical.d.2"> stays 1, so we can effectively ignore it entirely, but we added some plain values to our x and y coordinates. So, if we want to subtract p1.x and p1.y, we use:</span></p><p data-reactid=".ku3c6u2igw.2.$canonical.e"><img class="LaTeX SVG" src="images/latex/031d2c01553905f6ab97a7e54543f66b9fd427f0.svg" style="width:32.09985rem;height:4.1998500000000005rem;" data-reactid=".ku3c6u2igw.2.$canonical.e.0"/></p><p data-reactid=".ku3c6u2igw.2.$canonical.f"><span data-reactid=".ku3c6u2igw.2.$canonical.f.0">Running all our coordinates through this transformation gives a new set of coordinates, let&#x27;s call those </span><b data-reactid=".ku3c6u2igw.2.$canonical.f.1">U</b><span data-reactid=".ku3c6u2igw.2.$canonical.f.2">, where the first coordinate lies on (0,0), and the rest is still somewhat free. Our next job is to make sure point 2 ends up lying on the </span><i data-reactid=".ku3c6u2igw.2.$canonical.f.3">x=0</i><span data-reactid=".ku3c6u2igw.2.$canonical.f.4"> line, so what we want is a transformation matrix that, when we run it, subtracts </span><i data-reactid=".ku3c6u2igw.2.$canonical.f.5">x</i><span data-reactid=".ku3c6u2igw.2.$canonical.f.6"> from whatever </span><i data-reactid=".ku3c6u2igw.2.$canonical.f.7">x</i><span data-reactid=".ku3c6u2igw.2.$canonical.f.8"> we currently have. This is called </span><a href="https://en.wikipedia.org/wiki/Shear_matrix" data-reactid=".ku3c6u2igw.2.$canonical.f.9">shearing</a><span data-reactid=".ku3c6u2igw.2.$canonical.f.a">, and the typical x-shear matrix and its transformation looks like this:</span></p><p data-reactid=".ku3c6u2igw.2.$canonical.g"><img class="LaTeX SVG" src="images/latex/8e98c870c9d5b60bccf196d29e290f9de6657ce7.svg" style="width:15.67485rem;height:4.05rem;" data-reactid=".ku3c6u2igw.2.$canonical.g.0"/></p><p data-reactid=".ku3c6u2igw.2.$canonical.h"><span data-reactid=".ku3c6u2igw.2.$canonical.h.0">So we want some shearing value that, when multiplied by </span><i data-reactid=".ku3c6u2igw.2.$canonical.h.1">y</i><span data-reactid=".ku3c6u2igw.2.$canonical.h.2">, yields </span><i data-reactid=".ku3c6u2igw.2.$canonical.h.3">-x</i><span data-reactid=".ku3c6u2igw.2.$canonical.h.4">, so our x coordinate becomes zero. That value is simpy </span><i data-reactid=".ku3c6u2igw.2.$canonical.h.5">-x/y</i><span data-reactid=".ku3c6u2igw.2.$canonical.h.6">, because </span><i data-reactid=".ku3c6u2igw.2.$canonical.h.7">-x/y * y = -x</i><span data-reactid=".ku3c6u2igw.2.$canonical.h.8">. Done:</span></p><p data-reactid=".ku3c6u2igw.2.$canonical.i"><img class="LaTeX SVG" src="images/latex/585fa88864a98008c15225bdbeb0eb26a4653dab.svg" style="width:9.9rem;height:4.87485rem;" data-reactid=".ku3c6u2igw.2.$canonical.i.0"/></p><p data-reactid=".ku3c6u2igw.2.$canonical.j"><span data-reactid=".ku3c6u2igw.2.$canonical.j.0">Now, running this on all our points generates a new set of coordinates, let&#x27;s call those V, which now have point 1 on (0,0) and point 2 on (0, some-value), and we wanted it at (0,1), so we need to [do some scaling](https://en.wikipedia.org/wiki/Scaling_%28geometry%29) to make sure it ends up at (0,1). Additionally, we want point 3 to end up on (1,1), so we can also scale x to make sure its x-coordinate will be 1 after we run the transform. That means we&#x27;ll be x-scaling by 1/point3</span><sub data-reactid=".ku3c6u2igw.2.$canonical.j.1">x</sub><span data-reactid=".ku3c6u2igw.2.$canonical.j.2">, and y-scaling by point2</span><sub data-reactid=".ku3c6u2igw.2.$canonical.j.3">y</sub><span data-reactid=".ku3c6u2igw.2.$canonical.j.4">. This is really easy:</span></p><p data-reactid=".ku3c6u2igw.2.$canonical.k"><img class="LaTeX SVG" src="images/latex/bf9c60b59e6247de3fece63638a8333bdcd068a4.svg" style="width:10.04985rem;height:5.3248500000000005rem;" data-reactid=".ku3c6u2igw.2.$canonical.k.0"/></p><p data-reactid=".ku3c6u2igw.2.$canonical.l">Then, finally, this generates a new set of coordinates, let&#x27;s call those W, of which point 1 lies on (0,0), point 2 lies on (0,1), and point three lies on (1, ...) so all that&#x27;s left is to make sure point 3 ends up at (1,1) - but we can&#x27;t scale! Point 2 is already in the right place, and y-scaling would move it out of (0,1) again, so our only option is to y-shear point three, just like how we x-sheared point 2 earlier. In this case, we do the same trick, but with `y/x` rather than `x/y` because we&#x27;re not x-shearing but y-shearing. Additionally, we don&#x27;t actually want to end up at zero (which is what we did before) so we need to shear towards an offset, in this case 1:</p><p data-reactid=".ku3c6u2igw.2.$canonical.m"><img class="LaTeX SVG" src="images/latex/af412fd7df7faf35973314095ec6bf1cb28a8e34.svg" style="width:10.125rem;height:4.95rem;" data-reactid=".ku3c6u2igw.2.$canonical.m.0"/></p><p data-reactid=".ku3c6u2igw.2.$canonical.n">And this generates our final set of four coordinates. Of these, we already know that points 1 through 3 are (0,0), (0,1) and (1,1), and only the last coordinate is &quot;free&quot;. In fact, given any four starting coordinates, the resulting &quot;transformation mapped&quot; coordinate will be:</p><p data-reactid=".ku3c6u2igw.2.$canonical.o"><img class="LaTeX SVG" src="images/latex/66e084e9ee396b8cc40de3d0df9c4658dcd10e14.svg" style="width:31.57515rem;height:8.1rem;" data-reactid=".ku3c6u2igw.2.$canonical.o.0"/></p><p data-reactid=".ku3c6u2igw.2.$canonical.p">That looks very complex, but notice that every coordinate value is being offset by the initial translation, and a lot of terms in there repeat: it&#x27;s pretty easy to calculate this fast, since there&#x27;s so much we can cache and reuse while we compute this mapped coordinate!</p><p data-reactid=".ku3c6u2igw.2.$canonical.q">First, let&#x27;s just do that translation step as a &quot;preprocessing&quot; operation so we don&#x27;t have to subtract the values all the time. What does that leave?</p><p data-reactid=".ku3c6u2igw.2.$canonical.r"><img class="LaTeX SVG" src="images/latex/d2dc58a4a6951ff27e5b83fb9be239e2fbe0f7ce.svg" style="width:24.67485rem;height:4.05rem;" data-reactid=".ku3c6u2igw.2.$canonical.r.0"/></p><p data-reactid=".ku3c6u2igw.2.$canonical.s">Suddenly things look a lot simpler: the mapped x is fairly straight forward to compute, and we see that the mapped y actually contains the mapped x in its entirety, so we&#x27;ll have that part already available when we need to evaluate it. In fact, let&#x27;s pull out all those common factors to see just how simple this is:</p><p data-reactid=".ku3c6u2igw.2.$canonical.t"><img class="LaTeX SVG" src="images/latex/ebaea590e50dfce555e8ad2c63682fe9e6285f06.svg" style="width:29.100150000000003rem;height:2.6248500000000003rem;" data-reactid=".ku3c6u2igw.2.$canonical.t.0"/></p><p data-reactid=".ku3c6u2igw.2.$canonical.u">That&#x27;s kind of super-simple to write out in code, I think you&#x27;ll agree. Coding math tends to be easier than the formulae initially make it look!</p><div class="note" data-reactid=".ku3c6u2igw.2.$canonical.v"><h3 data-reactid=".ku3c6u2igw.2.$canonical.v.0">How do you track all that?</h3><p data-reactid=".ku3c6u2igw.2.$canonical.v.1"><span data-reactid=".ku3c6u2igw.2.$canonical.v.1.0">Doing maths can be a pain, so whenever possible, I like to make computers do the work for me. Especially for things like this, I simply use </span><a href="http://www.wolfram.com/mathematica" data-reactid=".ku3c6u2igw.2.$canonical.v.1.1">Mathematica</a><span data-reactid=".ku3c6u2igw.2.$canonical.v.1.2">. Tracking all this math by hand is insane, and we invented computers, literally, to do this for us. I have no reason to use pen and paper when I can write out what I want to do in a program, and have the program do the math for me. And real math, too, with symbols, not with numbers. In fact, </span><a href="http://pomax.github.io/gh-weblog/downloads/canonical-curve.nb" data-reactid=".ku3c6u2igw.2.$canonical.v.1.3">here&#x27;s</a><span data-reactid=".ku3c6u2igw.2.$canonical.v.1.4"> the Mathematica notebook if you want to see how this works for yourself.</span></p><p data-reactid=".ku3c6u2igw.2.$canonical.v.2"><span data-reactid=".ku3c6u2igw.2.$canonical.v.2.0">Now, I know, you&#x27;re thinking &quot;but Mathematica is super expensive!&quot; and that&#x27;s true, it&#x27;s </span><a href="http://www.wolfram.com/mathematica-home-edition" data-reactid=".ku3c6u2igw.2.$canonical.v.2.1">$295 for home use</a><span data-reactid=".ku3c6u2igw.2.$canonical.v.2.2">, but it&#x27;s </span><strong data-reactid=".ku3c6u2igw.2.$canonical.v.2.3">also</strong><span data-reactid=".ku3c6u2igw.2.$canonical.v.2.4"> </span><a href="http://www.wolfram.com/raspberry-pi" data-reactid=".ku3c6u2igw.2.$canonical.v.2.5">free when you buy a $35 raspberry pi</a><span data-reactid=".ku3c6u2igw.2.$canonical.v.2.6">. Obviously, I bought a raspberry pi, and I encourage you to do the same. With that, as long as you know what you want to </span><em data-reactid=".ku3c6u2igw.2.$canonical.v.2.7">do</em><span data-reactid=".ku3c6u2igw.2.$canonical.v.2.8">, Mathematica can just do it for you. And we don&#x27;t have to be geniusses to work out what the maths looks like. That&#x27;s what we have computers for.</span></p></div><p data-reactid=".ku3c6u2igw.2.$canonical.w">So, let&#x27;s write up a sketch that&#x27;ll show us the canonical form for any curve drawn in blue, overlaid on our canonical map, so that we can immediately tell which features our curve must have, based on where the fourth coordinate is located on the map:</p><figure class="false" data-reactid=".ku3c6u2igw.2.$canonical.x"><canvas tabindex="0" data-reactid=".ku3c6u2igw.2.$canonical.x.0"></canvas><figcaption data-reactid=".ku3c6u2igw.2.$canonical.x.1"><span data-reactid=".ku3c6u2igw.2.$canonical.x.1.0">A cubic curve mapped to canonical form</span><span data-reactid=".ku3c6u2igw.2.$canonical.x.1.1"> </span></figcaption></figure></section><table class="relatives after" data-reactid=".ku3c6u2igw.2.2"><tbody data-reactid=".ku3c6u2igw.2.2.0"><tr data-reactid=".ku3c6u2igw.2.2.0.0"><td data-reactid=".ku3c6u2igw.2.2.0.0.0"><a class="prev" href="tightbounds" data-reactid=".ku3c6u2igw.2.2.0.0.0.0">17. Tight boxes</a></td><td class="toc" data-reactid=".ku3c6u2igw.2.2.0.0.1"><a class="" href="/" data-reactid=".ku3c6u2igw.2.2.0.0.1.0">ToC</a></td><td data-reactid=".ku3c6u2igw.2.2.0.0.2"><a class="next" href="arclength" data-reactid=".ku3c6u2igw.2.2.0.0.2.0">19. Arc length</a></td></tr></tbody></table></div><footer class="copyright" data-reactid=".ku3c6u2igw.3"><span data-reactid=".ku3c6u2igw.3.0">This article is © 2011-2016 to me, Mike &quot;Pomax&quot; Kamermans, but the text, code, and images are </span><a href="https://github.com/Pomax/bezierinfo/blob/gh-pages/LICENSE.md" data-reactid=".ku3c6u2igw.3.1">almost no rights reserved</a><span data-reactid=".ku3c6u2igw.3.2">. Go do something cool with it!</span></footer></div>
</body>
</html>